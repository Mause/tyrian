
<!-- saved from url=(0061)http://peak.telecommunity.com/DevCenter/BytecodeAssembler#toc -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">

<script src="./BytecodeAssembler - The PEAK Developers' Center_files/functional.min.js"></script><style type="text/css"></style>
<title>BytecodeAssembler - The PEAK Developers' Center</title>
<meta name="KEYWORDS" content="Bytecode, Assembler">
<link rel="stylesheet" type="text/css" href="./BytecodeAssembler - The PEAK Developers' Center_files/moinmoin.css">
<link rel="Start" href="http://peak.telecommunity.com/DevCenter/FrontPage">
<link rel="Alternate" media="print" title="Print" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=print">
<link rel="Index" href="http://peak.telecommunity.com/DevCenter/TitleIndex">
<link rel="Glossary" href="http://peak.telecommunity.com/DevCenter/WordIndex">
<link rel="Help" href="http://peak.telecommunity.com/DevCenter/HelpOnFormatting">
</head>
<body onload="window.defaultStatus=&#39;The PEAK Developers&#39; Center&#39;" data-content-script-loaded="1"><a name="top"></a>
<table width="100%"><tbody><tr><td>
<a href="http://peak.telecommunity.com/DevCenter/FrontPage"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/peak3.gif" border="0" alt="The PEAK Developers&#39; Center"></a>
</td><td width="99%" valign="middle" class="headline"><font size="+3">&nbsp;<b>
<a title="Click here to do a full-text search for this title" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=fullsearch&value=BytecodeAssembler&literal=1&case=1">BytecodeAssembler</a>
</b></font></td>
<td valign="bottom" align="left" nowrap="">
<font face="Verdana" size="1"><a href="http://peak.telecommunity.com/DevCenter/UserPreferences">UserPreferences</a><br>&nbsp;</font>
</td></tr></tbody></table>

<a href="http://peak.telecommunity.com/DevCenter/HelpContents"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-help.gif" width="12" height="11" border="0" hspace="2" align="right" alt="HelpContents"></a>
<a href="http://peak.telecommunity.com/DevCenter/FindPage?value=BytecodeAssembler"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-search.gif" width="12" height="12" border="0" hspace="2" align="right" alt="Search"></a>
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=diff"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-diff.gif" width="15" height="11" border="0" hspace="2" align="right" alt="Diffs"></a>
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=info"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-info.gif" width="12" height="11" border="0" hspace="2" align="right" alt="Info"></a>
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=edit"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-edit.gif" width="12" height="12" border="0" hspace="2" align="right" alt="Edit"></a>
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=subscribe"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-email-x.gif" width="14" height="10" border="0" hspace="2" vspace="1" align="right" alt="Subscribe"></a>
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=format&mimetype=text/xml"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-xml.gif" width="20" height="13" border="0" hspace="2" align="right" alt="XML"></a>
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=print"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-print.gif" width="16" height="14" border="0" hspace="2" align="right" alt="Print"></a>
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler"><img src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-show.gif" width="12" height="13" border="0" hspace="2" align="right" alt="View"></a>

<table class="navibar" cellpadding="0" cellspacing="3" border="0"><tbody><tr><td class="navibar" valign="top" align="center" bgcolor="#E8E8E8"><font class="navibar" face="Arial,Helvetica" size="-1">&nbsp;<b>The PEAK Developers' Center</b>&nbsp;</font></td>
<td class="navibar" valign="top" align="center" bgcolor="#E8E8E8"><font class="navibar" face="Arial,Helvetica" size="-1">&nbsp;<a class="navibar" href="http://peak.telecommunity.com/DevCenter/FrontPage">FrontPage</a>&nbsp;</font></td>
<td class="navibar" valign="top" align="center" bgcolor="#E8E8E8"><font class="navibar" face="Arial,Helvetica" size="-1">&nbsp;<a class="navibar" href="http://peak.telecommunity.com/DevCenter/RecentChanges">RecentChanges</a>&nbsp;</font></td>
<td class="navibar" valign="top" align="center" bgcolor="#E8E8E8"><font class="navibar" face="Arial,Helvetica" size="-1">&nbsp;<a class="navibar" href="http://peak.telecommunity.com/DevCenter/TitleIndex">TitleIndex</a>&nbsp;</font></td>
<td class="navibar" valign="top" align="center" bgcolor="#E8E8E8"><font class="navibar" face="Arial,Helvetica" size="-1">&nbsp;<a class="navibar" href="http://peak.telecommunity.com/DevCenter/WordIndex">WordIndex</a>&nbsp;</font></td>
<td class="navibar" valign="top" align="center" bgcolor="#E8E8E8"><font class="navibar" face="Arial,Helvetica" size="-1">&nbsp;<a class="navibar" href="http://peak.telecommunity.com/DevCenter/SiteNavigation">SiteNavigation</a>&nbsp;</font></td>
<td class="navibar" valign="top" align="center" bgcolor="#E8E8E8"><font class="navibar" face="Arial,Helvetica" size="-1">&nbsp;<a class="navibar" href="http://peak.telecommunity.com/DevCenter/HelpContents">HelpContents</a>&nbsp;</font></td>
</tr></tbody></table>
<hr>
<div class="document" id="generating-python-bytecode-with-peak-util-assembler">
<h1 class="title">Generating Python Bytecode with <tt class="literal"><span class="pre">peak.util.assembler</span></tt></h1>
<p><tt class="literal"><span class="pre">peak.util.assembler</span></tt> is a simple bytecode assembler module that handles most
low-level bytecode generation details like jump offsets, stack size tracking,
line number table generation, constant and variable name index tracking, etc.
That way, you can focus your attention on the desired semantics of your
bytecode instead of on these mechanical issues.</p>
<p>In addition to a low-level opcode-oriented API for directly generating specific
Python bytecodes, this module also offers an extensible mini-AST framework for
generating code from high-level specifications.  This framework does most of
the work needed to transform tree-like structures into linear bytecode
instructions, and includes the ability to do compile-time constant folding.</p>
<p>Please see the <a class="reference" href="./BytecodeAssembler - The PEAK Developers' Center_files/BytecodeAssembler - The PEAK Developers' Center.htm">BytecodeAssembler reference manual</a> for more details.</p>
<p>Changes since version 0.5.2:</p>
<ul class="simple">
<li>Symbolic disassembly with full emulation of backward-compatible
<tt class="literal"><span class="pre">JUMP_IF_TRUE</span></tt> and <tt class="literal"><span class="pre">JUMP_IF_FALSE</span></tt> opcodes on Python 2.7 -- tests now
run clean on Python 2.7.</li>
<li>Support for backward emulation of Python 2.7's <tt class="literal"><span class="pre">JUMP_IF_TRUE_OR_POP</span></tt> and
<tt class="literal"><span class="pre">JUMP_IF_FALSE_OR_POP</span></tt> instructions on earlier Python versions; these
emulations are also used in BytecodeAssembler's internal code generation,
for maximum performance on 2.7+ (with no change to performance on older
versions).</li>
</ul>
<p>Changes since version 0.5.1:</p>
<ul class="simple">
<li>Initial support for Python 2.7's new opcodes and semantics changes, mostly
by emulating older versions' behavior with macros.  (0.5.2 is really just
a quick-fix release to allow packages using BytecodeAssembler to run on 2.7
without having to change any of their code generation; future releases will
provide proper support for the new and changed opcodes, as well as a test
suite that doesn't show spurious differences in the disassembly listings
under Python 2.7.)</li>
</ul>
<p>Changes since version 0.5:</p>
<ul class="simple">
<li>Fix incorrect stack size calculation for <tt class="literal"><span class="pre">MAKE_CLOSURE</span></tt> on Python 2.5+</li>
</ul>
<p>Changes since version 0.3:</p>
<ul class="simple">
<li>New node types:<ul>
<li><tt class="literal"><span class="pre">For(iterable,</span> <span class="pre">assign,</span> <span class="pre">body)</span></tt> -- define a "for" loop over <cite>iterable</cite></li>
<li><tt class="literal"><span class="pre">UnpackSequence(nodes)</span></tt> -- unpacks a sequence that's <tt class="literal"><span class="pre">len(nodes)</span></tt> long,
and then generates the given nodes.</li>
<li><tt class="literal"><span class="pre">LocalAssign(name)</span></tt> -- issues a <tt class="literal"><span class="pre">STORE_FAST</span></tt>, <tt class="literal"><span class="pre">STORE_DEREF</span></tt> or
<tt class="literal"><span class="pre">STORE_LOCAL</span></tt> as appropriate for the given name.</li>
<li><tt class="literal"><span class="pre">Function(body,</span> <span class="pre">name='&lt;lambda&gt;',</span> <span class="pre">args=(),</span> <span class="pre">var=None,</span> <span class="pre">kw=None,</span> <span class="pre">defaults=())</span></tt>
-- creates a nested function from <cite>body</cite> and puts it on the stack.</li>
<li><tt class="literal"><span class="pre">If(cond,</span> <span class="pre">then_,</span> <span class="pre">else_=Pass)</span></tt> -- "if" statement analogue</li>
<li><tt class="literal"><span class="pre">ListComp(body)</span></tt> and <tt class="literal"><span class="pre">LCAppend(value)</span></tt> -- implement list comprehensions</li>
<li><tt class="literal"><span class="pre">YieldStmt(value)</span></tt> -- generates a <tt class="literal"><span class="pre">YIELD_VALUE</span></tt> (plus a <tt class="literal"><span class="pre">POP_TOP</span></tt> in
Python 2.5+)</li>
</ul>
</li>
<li><tt class="literal"><span class="pre">Code</span></tt> objects are now iterable, yielding <tt class="literal"><span class="pre">(offset,</span> <span class="pre">op,</span> <span class="pre">arg)</span></tt> triples,
where <cite>op</cite> is numeric and <cite>arg</cite> is either numeric or <tt class="literal"><span class="pre">None</span></tt>.</li>
<li><tt class="literal"><span class="pre">Code</span></tt> objects' <tt class="literal"><span class="pre">.code()</span></tt> method can now take a "parent" <tt class="literal"><span class="pre">Code</span></tt> object,
to link the child code's free variables to cell variables in the parent.</li>
<li>Added <tt class="literal"><span class="pre">Code.from_spec()</span></tt> classmethod, that initializes a code object from a
name and argument spec.</li>
<li><tt class="literal"><span class="pre">Code</span></tt> objects now have a <tt class="literal"><span class="pre">.nested(name,</span> <span class="pre">args,</span> <span class="pre">var,</span> <span class="pre">kw)</span></tt> method, that
creates a child code object with the same <tt class="literal"><span class="pre">co_filename</span></tt> and the supplied
name/arg spec.</li>
<li>Fixed incorrect stack tracking for the <tt class="literal"><span class="pre">FOR_ITER</span></tt> and <tt class="literal"><span class="pre">YIELD_VALUE</span></tt>
opcodes</li>
<li>Ensure that <tt class="literal"><span class="pre">CO_GENERATOR</span></tt> flag is set if <tt class="literal"><span class="pre">YIELD_VALUE</span></tt> opcode is used</li>
<li>Change tests so that Python 2.3's broken line number handling in <tt class="literal"><span class="pre">dis.dis</span></tt>
and constant-folding optimizer don't generate spurious failures in this
package's test suite.</li>
</ul>
<p>Changes since version 0.2:</p>
<ul class="simple">
<li>Added <tt class="literal"><span class="pre">Suite</span></tt>, <tt class="literal"><span class="pre">TryExcept</span></tt>, and <tt class="literal"><span class="pre">TryFinally</span></tt> node types</li>
<li>Added a <tt class="literal"><span class="pre">Getattr</span></tt> node type that does static or dynamic attribute access
and constant folding</li>
<li>Fixed <tt class="literal"><span class="pre">code.from_function()</span></tt> not copying the <tt class="literal"><span class="pre">co_filename</span></tt> attribute when
<tt class="literal"><span class="pre">copy_lineno</span></tt> was specified.</li>
<li>The <tt class="literal"><span class="pre">repr()</span></tt> of AST nodes doesn't include a trailing comma for 1-argument
node types any more.</li>
<li>Added a <tt class="literal"><span class="pre">Pass</span></tt> symbol that generates no code, a <tt class="literal"><span class="pre">Compare()</span></tt> node type
that does n-way comparisons, and <tt class="literal"><span class="pre">And()</span></tt> and <tt class="literal"><span class="pre">Or()</span></tt> node types for doing
logical operations.</li>
<li>The <tt class="literal"><span class="pre">COMPARE_OP()</span></tt> method now accepts operator strings like <tt class="literal"><span class="pre">"&lt;="</span></tt>,
<tt class="literal"><span class="pre">"not</span> <span class="pre">in"</span></tt>, <tt class="literal"><span class="pre">"exception</span> <span class="pre">match"</span></tt>, and so on, as well as numeric opcodes.
See the standard library's <tt class="literal"><span class="pre">opcode</span></tt> module for a complete list of the
strings accepted (in the <tt class="literal"><span class="pre">cmp_op</span></tt> tuple).  <tt class="literal"><span class="pre">"&lt;&gt;"</span></tt> is also accepted as an
alias for <tt class="literal"><span class="pre">"!="</span></tt>.</li>
<li>Added code to verify that forward jump offsets don't exceed a 64KB span, and
support absolute backward jumps to locations &gt;64KB.</li>
</ul>
<p>Changes since version 0.1:</p>
<ul class="simple">
<li>Constant handling has been fixed so that it doesn't confuse equal values of
differing types (e.g. <tt class="literal"><span class="pre">1.0</span></tt> and <tt class="literal"><span class="pre">True</span></tt>), or equal unhashable objects
(e.g. two empty lists).</li>
<li>Removed <tt class="literal"><span class="pre">nil</span></tt>, <tt class="literal"><span class="pre">ast_curry()</span></tt> and <tt class="literal"><span class="pre">folding_curry()</span></tt>, replacing them with
the <tt class="literal"><span class="pre">nodetype()</span></tt> decorator and <tt class="literal"><span class="pre">fold_args()</span></tt>; please see the docs for
more details.</li>
<li>Added stack tracking across jumps, globally verifying stack level prediction
consistency and automatically rejecting attempts to generate dead code.  It
should now be virtually impossible to accidentally generate bytecode that can
crash the interpreter.  (If you find a way, let me know!)</li>
</ul>
<p>Changes since version 0.0.1:</p>
<ul class="simple">
<li>Added massive quantities of new documentation and examples</li>
<li>Full block, loop, and closure support</li>
<li>High-level functional code generation from trees, with smart labels and
blocks, constant folding, extensibility, smart local variable names, etc.</li>
<li>The <tt class="literal"><span class="pre">.label()</span></tt> method was renamed to <tt class="literal"><span class="pre">.here()</span></tt> to distinguish it from
the new smart <tt class="literal"><span class="pre">Label</span></tt> objects.</li>
<li>Docs and tests were moved to README.txt instead of assembler.txt</li>
<li>Added a demo that implements a "switch"-like statement template that shows
how to extend the code generation system and how to abuse <tt class="literal"><span class="pre">END_FINALLY</span></tt>
to implement a "computed goto" in bytecode.</li>
<li>Various bug fixes</li>
</ul>
<p>There are a few features that aren't tested yet, and not all opcodes may be
fully supported.  Also note the following limitations:</p>
<ul class="simple">
<li>Jumps to as-yet-undefined labels cannot span a distance greater than 65,535
bytes.</li>
<li>The <tt class="literal"><span class="pre">dis()</span></tt> function in Python 2.3 has a bug that makes it show incorrect
line numbers when the difference between two adjacent line numbers is
greater than 255.  (To work around this, the test_suite uses a later version
of <tt class="literal"><span class="pre">dis()</span></tt>, but do note that it may affect your own tests if you use
<tt class="literal"><span class="pre">dis()</span></tt> with Python 2.3 and use widely separated line numbers.)</li>
</ul>
<p>If you find any other issues, please let me know.</p>
<p>Please also keep in mind that this is a work in progress, and the API may
change if I come up with a better way to do something.</p>
<p>Questions and discussion regarding this software should be directed to the
<a class="reference" href="http://www.eby-sarna.com/mailman/listinfo/peak">PEAK Mailing List</a>.</p>
<a class="target" id="toc" name="toc"></a><div class="contents topic" id="table-of-contents">
<p class="topic-title"><a name="table-of-contents"><strong>Table of Contents</strong></a></p>
<ul class="simple">
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#programmer-api" id="id1" name="id1">Programmer API</a><ul>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#code-objects" id="id2" name="id2">Code Objects</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#symbolic-disassembler" id="id3" name="id3">Symbolic Disassembler</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#opcodes-and-arguments" id="id4" name="id4">Opcodes and Arguments</a><ul>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#call-arguments" id="id5" name="id5">Call Arguments</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#jump-targets" id="id6" name="id6">Jump Targets</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#other-special-opcodes" id="id7" name="id7">Other Special Opcodes</a></li>
</ul>
</li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#high-level-code-generation" id="id8" name="id8">High-Level Code Generation</a><ul>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#simple-constants" id="id9" name="id9">Simple Constants</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#simple-containers" id="id10" name="id10">Simple Containers</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#arbitrary-constants" id="id11" name="id11">Arbitrary Constants</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#suite-and-pass" id="id12" name="id12"><tt class="literal"><span class="pre">Suite</span></tt> and <tt class="literal"><span class="pre">Pass</span></tt></a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#local-and-global-names" id="id13" name="id13">Local and Global Names</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#obtaining-attributes" id="id14" name="id14">Obtaining Attributes</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#calling-functions-and-methods" id="id15" name="id15">Calling Functions and Methods</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#returning-values" id="id16" name="id16">Returning Values</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#if-conditions" id="id17" name="id17"><tt class="literal"><span class="pre">If</span></tt> Conditions</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#labels-and-jump-targets" id="id18" name="id18">Labels and Jump Targets</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#more-conditional-jump-instructions" id="id19" name="id19">More Conditional Jump Instructions</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#n-way-comparisons" id="id20" name="id20">N-Way Comparisons</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#sequence-unpacking" id="id21" name="id21">Sequence Unpacking</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#yield-statements" id="id22" name="id22">Yield Statements</a></li>
</ul>
</li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#constant-detection-and-folding" id="id23" name="id23">Constant Detection and Folding</a><ul>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#folding-function-calls" id="id24" name="id24">Folding Function Calls</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#logical-and-or" id="id25" name="id25">Logical And/Or</a></li>
</ul>
</li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#custom-code-generation" id="id26" name="id26">Custom Code Generation</a><ul>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#constant-folding-in-custom-targets" id="id27" name="id27">Constant Folding in Custom Targets</a></li>
</ul>
</li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#setting-the-code-s-calling-signature" id="id28" name="id28">Setting the Code's Calling Signature</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#code-attributes" id="id29" name="id29">Code Attributes</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#stack-size-tracking-and-dead-code-detection" id="id30" name="id30">Stack Size Tracking and Dead Code Detection</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#blocks-loops-and-exception-handling" id="id31" name="id31">Blocks, Loops, and Exception Handling</a><ul>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#exception-stack-size-adjustment" id="id32" name="id32">Exception Stack Size Adjustment</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#try-except-blocks" id="id33" name="id33">Try/Except Blocks</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#try-finally-blocks" id="id34" name="id34">Try/Finally Blocks</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#loops" id="id35" name="id35">Loops</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#break-and-continue" id="id36" name="id36">Break and Continue</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#for-loops" id="id37" name="id37"><tt class="literal"><span class="pre">for</span></tt> Loops</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#list-comprehensions" id="id38" name="id38">List Comprehensions</a></li>
</ul>
</li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#closures-and-nested-functions" id="id39" name="id39">Closures and Nested Functions</a><ul>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#free-and-cell-variables" id="id40" name="id40">Free and Cell Variables</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#nested-code-objects" id="id41" name="id41">Nested Code Objects</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#function" id="id42" name="id42"><tt class="literal"><span class="pre">Function()</span></tt></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#internals-and-doctests" id="id43" name="id43">Internals and Doctests</a><ul>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#demo-computed-goto-switch-statement" id="id44" name="id44">Demo: "Computed Goto"/"Switch Statement"</a></li>
<li><a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#todo" id="id45" name="id45">TODO</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="programmer-api">
<h1><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id1" name="programmer-api">Programmer API</a></h1>
<div class="section" id="code-objects">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id2" name="code-objects">Code Objects</a></h2>
<p>To generate bytecode, you create a <tt class="literal"><span class="pre">Code</span></tt> instance and perform operations
on it.  For example, here we create a <tt class="literal"><span class="pre">Code</span></tt> object representing lines
15 and 16 of some input source:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import Code
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.set_lineno(15)   # set the current line number (optional)
&gt;&gt;&gt; c.LOAD_CONST(42)

&gt;&gt;&gt; c.set_lineno(16)   # set it as many times as you like
&gt;&gt;&gt; c.RETURN_VALUE()
</pre>
<p>You'll notice that most <tt class="literal"><span class="pre">Code</span></tt> methods are named for a CPython bytecode
operation, but there also some other methods like <tt class="literal"><span class="pre">.set_lineno()</span></tt> to let you
set the current line number.  There's also a <tt class="literal"><span class="pre">.code()</span></tt> method that returns
a Python code object, representing the current state of the <tt class="literal"><span class="pre">Code</span></tt> you've
generated:</p>
<pre class="literal-block">&gt;&gt;&gt; from dis import dis
&gt;&gt;&gt; dis(c.code())
  15          0 LOAD_CONST               1 (42)
  16          3 RETURN_VALUE
</pre>
<p>As you can see, <tt class="literal"><span class="pre">Code</span></tt> instances automatically generate a line number table
that maps each <tt class="literal"><span class="pre">set_lineno()</span></tt> to the corresponding position in the bytecode.</p>
<p>And of course, the resulting code objects can be run with <tt class="literal"><span class="pre">eval()</span></tt> or
<tt class="literal"><span class="pre">exec</span></tt>, or used with <tt class="literal"><span class="pre">new.function</span></tt> to create a function:</p>
<pre class="literal-block">&gt;&gt;&gt; eval(c.code())
42

&gt;&gt;&gt; exec c.code()   # exec discards the return value, so no output here

&gt;&gt;&gt; import new
&gt;&gt;&gt; f = new.function(c.code(), globals())
&gt;&gt;&gt; f()
42
</pre>
<p>Finally, code objects are also iterable, yielding <tt class="literal"><span class="pre">(offset,</span> <span class="pre">opcode,</span> <span class="pre">arg)</span></tt>
tuples, where <cite>arg</cite> is <tt class="literal"><span class="pre">None</span></tt> for opcodes with no arguments, and an integer
otherwise:</p>
<pre class="literal-block">&gt;&gt;&gt; import peak.util.assembler as op
&gt;&gt;&gt; list(c) == [
...     (0, op.LOAD_CONST, 1),
...     (3, op.RETURN_VALUE, None)
... ]
True
</pre>
<p>This can be useful for testing or otherwise inspecting code you've generated.</p>
</div>
<div class="section" id="symbolic-disassembler">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id3" name="symbolic-disassembler">Symbolic Disassembler</a></h2>
<p>Python's built-in disassembler can be verbose and hard to read when inspecting
complex generated code -- usually you don't care about bytecode offsets or
line numbers as much as you care about labels, for example.</p>
<p>So, BytecodeAssembler provides its own, simplified disassembler, which we'll
be using for more complex listings in this manual:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import dump
</pre>
<p>Some sample output, that also showcases some of BytecodeAssembler's
<a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#high-level-code-generation">High-Level Code Generation</a> features:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; from peak.util.assembler import Compare, Local
&gt;&gt;&gt; c.return_(Compare(Local('a'), [('&lt;', Local('b')), ('&lt;', Local('c'))]))
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (a)
                LOAD_FAST                1 (b)
                DUP_TOP
                ROT_THREE
                COMPARE_OP               0 (&lt;)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_FAST                2 (c)
                COMPARE_OP               0 (&lt;)
                JUMP_FORWARD            L2
        L1:     ROT_TWO
                POP_TOP
        L2:     RETURN_VALUE
</pre>
<p>As you can see, the line numbers and bytecode offsets have been dropped,
making it esier to see where the jumps go.  (This also makes doctests more
robust against Python version changes, as <tt class="literal"><span class="pre">dump()</span></tt> has some extra code to
make conditional jumps appear consistent across the major changes that were
made to conditional jump instructions between Python 2.6 and 2.7.)</p>
</div>
<div class="section" id="opcodes-and-arguments">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id4" name="opcodes-and-arguments">Opcodes and Arguments</a></h2>
<p><tt class="literal"><span class="pre">Code</span></tt> objects have methods for all of CPython's symbolic opcodes.  Generally
speaking, each method accepts either zero or one argument, depending on whether
the opcode accepts an argument.</p>
<p>Python bytecode always encodes opcode arguments as 16 or 32-bit integers, but
sometimes these numbers are actually offsets into a sequence of names or
constants.  <tt class="literal"><span class="pre">Code</span></tt> objects take care of maintaining these sequences for you,
allowing you to just pass in a name or value directly, instead of needing to
keep track of what numbers map to what names or values.</p>
<p>The name or value you pass in to such methods will be looked up in the
appropriate table (see <a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#code-attributes">Code Attributes</a> below for a list), and if not found,
it will be added:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_consts, c.co_varnames, c.co_names
([None], [], [])

&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; c.LOAD_FAST('x')
&gt;&gt;&gt; c.LOAD_GLOBAL('y')
&gt;&gt;&gt; c.LOAD_NAME('z')

&gt;&gt;&gt; c.co_consts, c.co_varnames, c.co_names
([None, 42], ['x'], ['y', 'z'])
</pre>
<p>The one exception to this automatic addition feature is that opcodes referring
to "free" or "cell" variables will not automatically add new names, because the
names need to be defined first:</p>
<pre class="literal-block">&gt;&gt;&gt; c.LOAD_DEREF('q')
Traceback (most recent call last):
  ...
NameError: ('Undefined free or cell var', 'q')
</pre>
<p>In general, opcode methods take the same arguments as their Python bytecode
equivalent.  But there are a few special cases.</p>
<div class="section" id="call-arguments">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id5" name="call-arguments">Call Arguments</a></h3>
<p>First, the <tt class="literal"><span class="pre">CALL_FUNCTION()</span></tt>, <tt class="literal"><span class="pre">CALL_FUNCTION_VAR()</span></tt>, <tt class="literal"><span class="pre">CALL_FUNCTION_KW()</span></tt>,
and <tt class="literal"><span class="pre">CALL_FUNCTION_VAR_KW()</span></tt> methods all take <em>two</em> arguments, both of which
are optional.  (The <tt class="literal"><span class="pre">_VAR</span></tt> and <tt class="literal"><span class="pre">_KW</span></tt> suffixes in the method names indicate
whether or not a <tt class="literal"><span class="pre">*args</span></tt> or <tt class="literal"><span class="pre">**kwargs</span></tt> or both are also present on the
stack, in addition to the explicit positional and keyword arguments.)</p>
<p>The first argument of each of these methods, is the number of positional
arguments on the stack, and the second is the number of keyword/value pairs on
the stack (to be used as keyword arguments).  Both default to zero if not
supplied:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(type)
&gt;&gt;&gt; c.LOAD_CONST(27)
&gt;&gt;&gt; c.CALL_FUNCTION(1)      # 1 positional, no keywords
&gt;&gt;&gt; c.RETURN_VALUE()

&gt;&gt;&gt; eval(c.code())          # computes type(27)
&lt;type 'int'&gt;

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(dict)
&gt;&gt;&gt; c.LOAD_CONST('x')
&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; c.CALL_FUNCTION(0,1)    # no positional, 1 keyword
&gt;&gt;&gt; c.RETURN_VALUE()

&gt;&gt;&gt; eval(c.code())          # computes dict(x=42)
{'x': 42}
</pre>
</div>
<div class="section" id="jump-targets">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id6" name="jump-targets">Jump Targets</a></h3>
<p>Opcodes that perform jumps or refer to addresses can be invoked in one of
two ways.  First, if you are jumping backwards (e.g. with <tt class="literal"><span class="pre">JUMP_ABSOLUTE</span></tt> or
<tt class="literal"><span class="pre">CONTINUE_LOOP</span></tt>), you can obtain the target bytecode offset using the
<tt class="literal"><span class="pre">.here()</span></tt> method, and then later pass that offset into the appropriate
method:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; where = c.here()         # get a location near the start of the code
&gt;&gt;&gt; c.DUP_TOP()
&gt;&gt;&gt; c.POP_TOP()
&gt;&gt;&gt; c.JUMP_ABSOLUTE(where)   # now jump back to it

&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 (42)
        L1:     DUP_TOP
                POP_TOP
                JUMP_ABSOLUTE            L1
</pre>
<p>But if you are jumping <em>forward</em>, you will need to call the jump or setup
method without any arguments.  The return value will be a "forward reference"
object that can be called later to indicate that the desired jump target has
been reached:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(99)
&gt;&gt;&gt; forward = c.JUMP_IF_TRUE() # create a jump and a forward reference

&gt;&gt;&gt; c.LOAD_CONST(42)            # this is what we want to skip over
&gt;&gt;&gt; c.POP_TOP()

&gt;&gt;&gt; forward()   # calling the reference changes the jump to point here
&gt;&gt;&gt; c.LOAD_CONST(23)
&gt;&gt;&gt; c.RETURN_VALUE()

&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 (99)
                JUMP_IF_TRUE             L1
                LOAD_CONST               2 (42)
                POP_TOP
        L1:     LOAD_CONST               3 (23)
                RETURN_VALUE

&gt;&gt;&gt; eval(c.code())
23
</pre>
</div>
<div class="section" id="other-special-opcodes">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id7" name="other-special-opcodes">Other Special Opcodes</a></h3>
<p>The <tt class="literal"><span class="pre">MAKE_CLOSURE</span></tt> method takes an argument for the number of default values
on the stack, just like the "real" Python opcode.  However, it also has an
an additional required argument: the number of closure cells on the stack.
The Python interpreter normally gets this number from a code object that's on
the stack, but <tt class="literal"><span class="pre">Code</span></tt> objects need this value in order to update the
current stack size, for purposes of computing the required total stack size:</p>
<pre class="literal-block">&gt;&gt;&gt; def x(a,b):     # a simple closure example
...     def y():
...         return a+b
...     return y

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_cellvars = ('a','b')

&gt;&gt;&gt; import sys
&gt;&gt;&gt; c.LOAD_CLOSURE('a')
&gt;&gt;&gt; c.LOAD_CLOSURE('b')
&gt;&gt;&gt; if sys.version&gt;='2.5':
...     c.BUILD_TUPLE(2) # In Python 2.5+, free vars must be in a tuple
&gt;&gt;&gt; c.LOAD_CONST(None)   # in real code, this'd be a Python code constant
&gt;&gt;&gt; c.MAKE_CLOSURE(0,2)  # no defaults, 2 free vars in the new function

&gt;&gt;&gt; c.stack_size         # This will be 1, no matter what Python version
1
</pre>
<p>The <tt class="literal"><span class="pre">COMPARE_OP</span></tt> method takes an argument which can be a valid comparison
integer constant, or a string containing a Python operator, e.g.:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.LOAD_CONST(2)
&gt;&gt;&gt; c.COMPARE_OP('not in')
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 COMPARE_OP               7 (not in)
</pre>
<p>The full list of valid operator strings can be found in the standard library's
<tt class="literal"><span class="pre">opcode</span></tt> module.  <tt class="literal"><span class="pre">"&lt;&gt;"</span></tt> is also accepted as an alias for <tt class="literal"><span class="pre">"!="</span></tt>:</p>
<pre class="literal-block">&gt;&gt;&gt; c.LOAD_CONST(3)
&gt;&gt;&gt; c.COMPARE_OP('&lt;&gt;')
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 COMPARE_OP               7 (not in)
              9 LOAD_CONST               3 (3)
             12 COMPARE_OP               3 (!=)
</pre>
</div>
</div>
<div class="section" id="high-level-code-generation">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id8" name="high-level-code-generation">High-Level Code Generation</a></h2>
<p>Typical real-life code generation use cases call for transforming tree-like
data structures into bytecode, rather than linearly outputting instructions.
<tt class="literal"><span class="pre">Code</span></tt> objects provide for this using a simple but high-level transformation
API.</p>
<p><tt class="literal"><span class="pre">Code</span></tt> objects may be <em>called</em>, passing in one or more arguments.  Each
argument will have bytecode generated for it, according to its type:</p>
<div class="section" id="simple-constants">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id9" name="simple-constants">Simple Constants</a></h3>
<p>If an argument is an integer, long, float, complex, string, unicode, boolean,
<tt class="literal"><span class="pre">None</span></tt>, or Python code object, it is treated as though it was passed to
the <tt class="literal"><span class="pre">LOAD_CONST</span></tt> method directly:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(1, 2L, 3.0, 4j+5, "6", u"7", False, None, c.code())
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2L)
              6 LOAD_CONST               3 (3.0)
              9 LOAD_CONST               4 ((5+4j))
             12 LOAD_CONST               5 ('6')
             15 LOAD_CONST               6 (u'7')
             18 LOAD_CONST               7 (False)
             21 LOAD_CONST               0 (None)
             24 LOAD_CONST               8 (&lt;code object &lt;lambda&gt; at ...&gt;)
</pre>
<p>Note that although some values of different types may compare equal to each
other, <tt class="literal"><span class="pre">Code</span></tt> objects will not substitute a value of a different type than
the one you requested:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(1, True, 1.0, 1L)     # equal, but different types
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (True)
              6 LOAD_CONST               3 (1.0)
              9 LOAD_CONST               4 (1L)
</pre>
</div>
<div class="section" id="simple-containers">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id10" name="simple-containers">Simple Containers</a></h3>
<p>If an argument is a tuple, list, or dictionary, code is generated to
reconstruct the given data, recursively:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c({1:(2,"3"), 4:[5,6]})
&gt;&gt;&gt; dis(c.code())
  0           0 BUILD_MAP                0
              3 DUP_TOP
              4 LOAD_CONST               1 (1)
              7 LOAD_CONST               2 (2)
             10 LOAD_CONST               3 ('3')
             13 BUILD_TUPLE              2
             16 ROT_THREE
             17 STORE_SUBSCR
             18 DUP_TOP
             19 LOAD_CONST               4 (4)
             22 LOAD_CONST               5 (5)
             25 LOAD_CONST               6 (6)
             28 BUILD_LIST               2
             31 ROT_THREE
             32 STORE_SUBSCR
</pre>
</div>
<div class="section" id="arbitrary-constants">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id11" name="arbitrary-constants">Arbitrary Constants</a></h3>
<p>The <tt class="literal"><span class="pre">Const</span></tt> wrapper allows you to treat any object as a literal constant,
regardless of its type:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import Const

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( Const( (1,2,3) ) )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 ((1, 2, 3))
</pre>
<p>As you can see, the above creates code that references an actual tuple as
a constant, rather than generating code to recreate the tuple using a series of
<tt class="literal"><span class="pre">LOAD_CONST</span></tt> operations followed by a <tt class="literal"><span class="pre">BUILD_TUPLE</span></tt>.</p>
<p>If the value wrapped in a <tt class="literal"><span class="pre">Const</span></tt> is not hashable, it is compared by identity
rather than value.  This prevents equal mutable values from being reused by
accident, e.g. if you plan to mutate the "constant" values later:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(Const([]), Const([]))     # equal, but not the same object!
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 ([])
              3 LOAD_CONST               2 ([])
</pre>
<p>Thus, although <tt class="literal"><span class="pre">Const</span></tt> objects hash and compare based on equality for
hashable types:</p>
<pre class="literal-block">&gt;&gt;&gt; hash(Const(3)) == hash(3)
True
&gt;&gt;&gt; Const(3)==Const(3)
True
</pre>
<p>They hash and compare based on object identity for non-hashable types:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Const([])
&gt;&gt;&gt; hash(c) == hash(id(c.value))
True
&gt;&gt;&gt; c == Const(c.value)     # compares equal if same object
True
&gt;&gt;&gt; c == Const([])          # but is not equal to a merely equal object
False
</pre>
</div>
<div class="section" id="suite-and-pass">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id12" name="suite-and-pass"><tt class="literal"><span class="pre">Suite</span></tt> and <tt class="literal"><span class="pre">Pass</span></tt></a></h3>
<p>On occasion, it's helpful to be able to group a sequence of opcodes,
expressions, or statements together, to be passed as an argument to other node
types.  The <tt class="literal"><span class="pre">Suite</span></tt> node type accomplishes this:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import Suite, Pass

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_(Suite([Const(42), Code.DUP_TOP, Code.POP_TOP]))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 DUP_TOP
              4 POP_TOP
              5 RETURN_VALUE
</pre>
<p>And <tt class="literal"><span class="pre">Pass</span></tt> is a shortcut for an empty <tt class="literal"><span class="pre">Suite</span></tt>, that generates nothing:</p>
<pre class="literal-block">&gt;&gt;&gt; Suite([])
Pass

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(Pass)
&gt;&gt;&gt; c.return_(None)
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE
</pre>
</div>
<div class="section" id="local-and-global-names">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id13" name="local-and-global-names">Local and Global Names</a></h3>
<p>The <tt class="literal"><span class="pre">Local</span></tt> and <tt class="literal"><span class="pre">Global</span></tt> wrappers take a name, and load either a local or
global variable, respectively:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import Global, Local

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( Local('x'), Global('y') )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_FAST                0 (x)
              3 LOAD_GLOBAL              0 (y)
</pre>
<p>As with simple constants and <tt class="literal"><span class="pre">Const</span></tt> wrappers, these objects can be used to
construct more complex expressions, like <tt class="literal"><span class="pre">{a:(b,c)}</span></tt>:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( {Local('a'): (Local('b'), Local('c'))} )
&gt;&gt;&gt; dis(c.code())
  0           0 BUILD_MAP                0
              3 DUP_TOP
              4 LOAD_FAST                0 (a)
              7 LOAD_FAST                1 (b)
             10 LOAD_FAST                2 (c)
             13 BUILD_TUPLE              2
             16 ROT_THREE
             17 STORE_SUBSCR
</pre>
<p>The <tt class="literal"><span class="pre">LocalAssign</span></tt> node type takes a name, and stores a value in a local
variable:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import LocalAssign
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(42, LocalAssign('x'))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_FAST               0 (x)
</pre>
<p>If the code object is not using "fast locals" (i.e. <tt class="literal"><span class="pre">CO_OPTIMIZED</span></tt> isn't
set), local variables will be referenced using <tt class="literal"><span class="pre">LOAD_NAME</span></tt> and <tt class="literal"><span class="pre">STORE_NAME</span></tt>
instead of <tt class="literal"><span class="pre">LOAD_FAST</span></tt> and <tt class="literal"><span class="pre">STORE_FAST</span></tt>, and if the referenced local name
is a "cell" or "free" variable, <tt class="literal"><span class="pre">LOAD_DEREF</span></tt> and <tt class="literal"><span class="pre">STORE_DEREF</span></tt> are used
instead:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import CO_OPTIMIZED
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_flags &amp;= ~CO_OPTIMIZED
&gt;&gt;&gt; c.co_cellvars = ('y',)
&gt;&gt;&gt; c.co_freevars = ('z',)
&gt;&gt;&gt; c( Local('x'), Local('y'), Local('z') )
&gt;&gt;&gt; c( LocalAssign('x'), LocalAssign('y'), LocalAssign('z') )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_NAME                0 (x)
              3 LOAD_DEREF               0 (y)
              6 LOAD_DEREF               1 (z)
              9 STORE_NAME               0 (x)
             12 STORE_DEREF              0 (y)
             15 STORE_DEREF              1 (z)
</pre>
</div>
<div class="section" id="obtaining-attributes">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id14" name="obtaining-attributes">Obtaining Attributes</a></h3>
<p>The <tt class="literal"><span class="pre">Getattr</span></tt> node type takes an expression and an attribute name.  The
attribute name can be a constant string, in which case a <tt class="literal"><span class="pre">LOAD_ATTR</span></tt> opcode
is used, and constant folding is done if possible:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import Getattr

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(Getattr(Local('x'), '__class__'))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_FAST                0 (x)
              3 LOAD_ATTR                0 (__class__)


&gt;&gt;&gt; Getattr(Const(object), '__class__') # const expression, const result
Const(&lt;type 'type'&gt;)
</pre>
<p>Or the attribute name can be an expression, in which case a <tt class="literal"><span class="pre">getattr()</span></tt> call
is compiled instead:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(Getattr(Local('x'), Local('y')))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (&lt;built-in function getattr&gt;)
              3 LOAD_FAST                0 (x)
              6 LOAD_FAST                1 (y)
              9 CALL_FUNCTION            2
</pre>
</div>
<div class="section" id="calling-functions-and-methods">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id15" name="calling-functions-and-methods">Calling Functions and Methods</a></h3>
<blockquote>
<pre class="doctest-block">&gt;&gt;&gt; from peak.util.assembler import Call
</pre>
</blockquote>
<p>The <tt class="literal"><span class="pre">Call</span></tt> wrapper takes 1-4 arguments: the expression to be called, a
sequence of positional arguments, a sequence of keyword/value pairs for
explicit keyword arguments, an "*" argument, and a "**" argument.  To omit any
of the optional arguments, just pass in an empty sequence in its place:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( Call(Global('type'), [Const(27)]) )

&gt;&gt;&gt; dis(c.code())   # type(27)
  0           0 LOAD_GLOBAL              0 (type)
              3 LOAD_CONST               1 (27)
              6 CALL_FUNCTION            1

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(Call(Global('dict'), (), [('x', 42)]))

&gt;&gt;&gt; dis(c.code())   # dict(x=42)
  0           0 LOAD_GLOBAL              0 (dict)
              3 LOAD_CONST               1 ('x')
              6 LOAD_CONST               2 (42)
              9 CALL_FUNCTION            256

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(Call(Global('foo'), (), (), Local('args'), Local('kw')))

&gt;&gt;&gt; dis(c.code())   # foo(*args, **kw)
  0           0 LOAD_GLOBAL              0 (foo)
              3 LOAD_FAST                0 (args)
              6 LOAD_FAST                1 (kw)
              9 CALL_FUNCTION_VAR_KW     0
</pre>
</div>
<div class="section" id="returning-values">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id16" name="returning-values">Returning Values</a></h3>
<p>The <tt class="literal"><span class="pre">Return(target)</span></tt> wrapper generates code for its target, followed by
a <tt class="literal"><span class="pre">RETURN_VALUE</span></tt> opcode:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import Return

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( Return(1) )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (1)
              3 RETURN_VALUE
</pre>
<p><tt class="literal"><span class="pre">Code</span></tt> objects also have a <tt class="literal"><span class="pre">return_()</span></tt> method that provides a more compact
spelling of the same thing:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_((1,2))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 BUILD_TUPLE              2
              9 RETURN_VALUE
</pre>
<p>Both <tt class="literal"><span class="pre">Return</span></tt> and <tt class="literal"><span class="pre">return_()</span></tt> can be used with no argument, in which case
<tt class="literal"><span class="pre">None</span></tt> is returned:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_()
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( Return() )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE
</pre>
</div>
<div class="section" id="if-conditions">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id17" name="if-conditions"><tt class="literal"><span class="pre">If</span></tt> Conditions</a></h3>
<p>The <tt class="literal"><span class="pre">If()</span></tt> node type generates conditional code, roughly equivalent to a
Python if/else statement:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import If
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( If(Local('a'), Return(42), Return(55)) )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (a)
                JUMP_IF_FALSE            L1
                POP_TOP
                LOAD_CONST               1 (42)
                RETURN_VALUE
        L1:     POP_TOP
                LOAD_CONST               2 (55)
                RETURN_VALUE
</pre>
<p>However, it can also be used like a Python 2.5+ conditional expression
(regardless of the targeted Python version):</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( Return(If(Local('a'), 42, 55)) )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (a)
                JUMP_IF_FALSE            L1
                POP_TOP
                LOAD_CONST               1 (42)
                JUMP_FORWARD             L2
        L1:     POP_TOP
                LOAD_CONST               2 (55)
        L2:     RETURN_VALUE
</pre>
<p>Note that <tt class="literal"><span class="pre">If()</span></tt> does <em>not</em> do constant-folding on its condition; even if the
condition is a constant, it will be tested at runtime.  This avoids issues with
using mutable constants, e.g.:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(If(Const([]), 42, 55))
&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 ([])
                JUMP_IF_FALSE            L1
                POP_TOP
                LOAD_CONST               2 (42)
                JUMP_FORWARD             L2
        L1:     POP_TOP
                LOAD_CONST               3 (55)
</pre>
</div>
<div class="section" id="labels-and-jump-targets">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id18" name="labels-and-jump-targets">Labels and Jump Targets</a></h3>
<p>The forward reference callbacks returned by jump operations are also usable
as code generation values, indicating that the jump should go to the
current location.  For example:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(99)
&gt;&gt;&gt; forward = c.JUMP_IF_FALSE()
&gt;&gt;&gt; c( 1, Code.POP_TOP, forward, Return(3) )
&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 (99)
                JUMP_IF_FALSE            L1
                LOAD_CONST               2 (1)
                POP_TOP
        L1:     LOAD_CONST               3 (3)
                RETURN_VALUE
</pre>
<p>However, there's an easier way to do the same thing, using <tt class="literal"><span class="pre">Label</span></tt> objects:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import Label
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; skip = Label()

&gt;&gt;&gt; c(99, skip.JUMP_IF_FALSE, 1, Code.POP_TOP, skip, Return(3))
&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 (99)
                JUMP_IF_FALSE            L1
                LOAD_CONST               2 (1)
                POP_TOP
        L1:     LOAD_CONST               3 (3)
                RETURN_VALUE
</pre>
<p>This approach has the advantage of being easy to use in complex trees.
<tt class="literal"><span class="pre">Label</span></tt> objects have attributes corresponding to every opcode that uses a
bytecode address argument.  Generating code for these attributes emits the
the corresponding opcode, and generating code for the label itself defines
where the previous opcodes will jump to.  Labels can have multiple jumps
targeting them, either before or after they are defined.  But they can't be
defined more than once:</p>
<pre class="literal-block">&gt;&gt;&gt; c(skip)
Traceback (most recent call last):
  ...
AssertionError: Label previously defined
</pre>
</div>
<div class="section" id="more-conditional-jump-instructions">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id19" name="more-conditional-jump-instructions">More Conditional Jump Instructions</a></h3>
<p>In Python 2.7, the traditional <tt class="literal"><span class="pre">JUMP_IF_TRUE</span></tt> and <tt class="literal"><span class="pre">JUMP_IF_FALSE</span></tt>
instructions were replaced with four new instructions that either conditionally
or unconditionally pop the value being tested.  This was done to improve
performance, since virtually all conditional jumps in Python code pop the
value on one branch or the other.</p>
<p>To provide better cross-version compatibility, BytecodeAssembler emulates the
old instructions on Python 2.7 by emitting a <tt class="literal"><span class="pre">DUP_TOP</span></tt> followed by a
<tt class="literal"><span class="pre">POP_JUMP_IF_FALSE</span></tt> or <tt class="literal"><span class="pre">POP_JUMP_IF_TRUE</span></tt> instruction.</p>
<p>However, since this decreases performance, BytecodeAssembler <em>also</em> emulates
Python 2.7's <tt class="literal"><span class="pre">JUMP_IF_FALSE_OR_POP</span></tt> and <tt class="literal"><span class="pre">JUMP_IF_FALSE_OR_TRUE</span></tt> opcodes
on <em>older</em> Pythons:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; l1, l2 = Label(), Label()
&gt;&gt;&gt; c(Local('a'), l1.JUMP_IF_FALSE_OR_POP, Return(27), l1)
&gt;&gt;&gt; c(l2.JUMP_IF_TRUE_OR_POP, Return(42), l2, Code.RETURN_VALUE)
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (a)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_CONST               1 (27)
                RETURN_VALUE
        L1:     JUMP_IF_TRUE            L2
                POP_TOP
                LOAD_CONST               2 (42)
                RETURN_VALUE
        L2:     RETURN_VALUE
</pre>
<p>This means that you can immediately begin using the "or-pop" variations, in
place of a jump followed by a pop, and BytecodeAssembler will use the faster
single instruction automatically on Python 2.7+.</p>
<p>BytecodeAssembler <em>also</em> supports using Python 2.7's conditional jumps
that do unconditional pops, but currently cannot emulate them on older Python
versions, so at the moment you should use them only when your code requires
Python 2.7.</p>
<p>(Note: for ease in doctesting across Python versions, the <tt class="literal"><span class="pre">dump()</span></tt> function
<em>always</em> shows the code as if it were generated for Python 2.6 or lower, so
if you need to check the <em>actual</em> bytecodes generated, you must use Python's
<tt class="literal"><span class="pre">dis.dis()</span></tt> function instead!)</p>
</div>
<div class="section" id="n-way-comparisons">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id20" name="n-way-comparisons">N-Way Comparisons</a></h3>
<p>You can generate N-way comparisons using the <tt class="literal"><span class="pre">Compare()</span></tt> node type:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import Compare

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(Compare(Local('a'), [('&lt;', Local('b'))]))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_FAST                0 (a)
              3 LOAD_FAST                1 (b)
              6 COMPARE_OP               0 (&lt;)
</pre>
<p>3-way comparisons generate code that's a bit more complex.  Here's a three-way
comparison (<tt class="literal"><span class="pre">a&lt;b&lt;c</span></tt>):</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_(Compare(Local('a'), [('&lt;', Local('b')), ('&lt;', Local('c'))]))
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (a)
                LOAD_FAST                1 (b)
                DUP_TOP
                ROT_THREE
                COMPARE_OP               0 (&lt;)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_FAST                2 (c)
                COMPARE_OP               0 (&lt;)
                JUMP_FORWARD            L2
        L1:     ROT_TWO
                POP_TOP
        L2:     RETURN_VALUE
</pre>
<p>And a four-way (<tt class="literal"><span class="pre">a&lt;b&gt;c!=d</span></tt>):</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_(
...     Compare( Local('a'), [
...         ('&lt;', Local('b')), ('&gt;', Local('c')), ('!=', Local('d'))
...     ])
... )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (a)
                LOAD_FAST                1 (b)
                DUP_TOP
                ROT_THREE
                COMPARE_OP               0 (&lt;)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_FAST                2 (c)
                DUP_TOP
                ROT_THREE
                COMPARE_OP               4 (&gt;)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_FAST                3 (d)
                COMPARE_OP               3 (!=)
                JUMP_FORWARD            L2
        L1:     ROT_TWO
                POP_TOP
        L2:     RETURN_VALUE
</pre>
</div>
<div class="section" id="sequence-unpacking">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id21" name="sequence-unpacking">Sequence Unpacking</a></h3>
<p>The <tt class="literal"><span class="pre">UnpackSequence</span></tt> node type takes a sequence of code generation targets,
and generates an <tt class="literal"><span class="pre">UNPACK_SEQUENCE</span></tt> of the correct length, followed by the
targets:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import UnpackSequence
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c((1,2), UnpackSequence([LocalAssign('x'), LocalAssign('y')]))
&gt;&gt;&gt; dis(c.code())   # x, y = 1, 2
  0           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 BUILD_TUPLE              2
              9 UNPACK_SEQUENCE          2
             12 STORE_FAST               0 (x)
             15 STORE_FAST               1 (y)
</pre>
</div>
<div class="section" id="yield-statements">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id22" name="yield-statements">Yield Statements</a></h3>
<p>The <tt class="literal"><span class="pre">YieldStmt</span></tt> node type generates the necessary opcode(s) for a <tt class="literal"><span class="pre">yield</span></tt>
statement, based on the target Python version.  (In Python 2.5+, a <tt class="literal"><span class="pre">POP_TOP</span></tt>
must be generated after a <tt class="literal"><span class="pre">YIELD_VALUE</span></tt> in order to create a yield statement,
as opposed to a yield expression.)  It also sets the code flags needed to make
the resulting code object a generator:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import YieldStmt
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(YieldStmt(1), YieldStmt(2), Return(None))
&gt;&gt;&gt; list(eval(c.code()))
[1, 2]
</pre>
</div>
</div>
<div class="section" id="constant-detection-and-folding">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id23" name="constant-detection-and-folding">Constant Detection and Folding</a></h2>
<p>The <tt class="literal"><span class="pre">const_value()</span></tt> function can be used to check if an expression tree has
a constant value, and to obtain that value.  Simple constants are returned
as-is:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import const_value

&gt;&gt;&gt; simple_values = [1, 2L, 3.0, 4j+5, "6", u"7", False, None, c.code()]

&gt;&gt;&gt; map(const_value, simple_values)
[1, 2L, 3.0, (5+4j), '6', u'7', False, None, &lt;code object &lt;lambda&gt; ...&gt;]
</pre>
<p>Values wrapped in a <tt class="literal"><span class="pre">Const()</span></tt> are also returned as-is:</p>
<pre class="literal-block">&gt;&gt;&gt; map(const_value, map(Const, simple_values))
[1, 2L, 3.0, (5+4j), '6', u'7', False, None, &lt;code object &lt;lambda&gt; ...&gt;]
</pre>
<p>But no other node types produce constant values; instead, <tt class="literal"><span class="pre">NotAConstant</span></tt> is
raised:</p>
<pre class="literal-block">&gt;&gt;&gt; const_value(Local('x'))
Traceback (most recent call last):
  ...
NotAConstant: Local('x')
</pre>
<p>Tuples of constants are recursively replaced by constant tuples:</p>
<pre class="literal-block">&gt;&gt;&gt; const_value( (1,2) )
(1, 2)

&gt;&gt;&gt; const_value( (1, (2, Const(3))) )
(1, (2, 3))
</pre>
<p>But any non-constant values anywhere in the structure cause an error:</p>
<pre class="literal-block">&gt;&gt;&gt; const_value( (1,Global('y')) )
Traceback (most recent call last):
  ...
NotAConstant: Global('y')
</pre>
<p>As do any types not previously described here:</p>
<pre class="literal-block">&gt;&gt;&gt; const_value([1,2])
Traceback (most recent call last):
  ...
NotAConstant: [1, 2]
</pre>
<p>Unless of course they're wrapped with <tt class="literal"><span class="pre">Const</span></tt>:</p>
<pre class="literal-block">&gt;&gt;&gt; const_value(Const([1,2]))
[1, 2]
</pre>
<div class="section" id="folding-function-calls">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id24" name="folding-function-calls">Folding Function Calls</a></h3>
<p>The <tt class="literal"><span class="pre">Call</span></tt> wrapper can also do simple constant folding, if all of its input
parameters are constants.  (Actually, the <cite>args</cite> and <cite>kwargs</cite> arguments must be
<em>sequences</em> of constants and 2-tuples of constants, respectively.)</p>
<p>If a <tt class="literal"><span class="pre">Call</span></tt> can thus compute its value in advance, it does so, returning a
<tt class="literal"><span class="pre">Const</span></tt> node instead of a <tt class="literal"><span class="pre">Call</span></tt> node:</p>
<pre class="literal-block">&gt;&gt;&gt; Call( Const(type), [1] )
Const(&lt;type 'int'&gt;)
</pre>
<p>Thus, you can also take the <tt class="literal"><span class="pre">const_value()</span></tt> of such calls:</p>
<pre class="literal-block">&gt;&gt;&gt; const_value( Call( Const(dict), [], [('x',27)] ) )
{'x': 27}
</pre>
<p>Which means that constant folding can propagate up an AST if the result is
passed in to another <tt class="literal"><span class="pre">Call</span></tt>:</p>
<pre class="literal-block">&gt;&gt;&gt; Call(Const(type), [Call( Const(dict), [], [('x',27)] )])
Const(&lt;type 'dict'&gt;)
</pre>
<p>Notice that this folding takes place eagerly, during AST construction.  If you
want to implement delayed folding after constant propagation or variable
substitution, you'll need to recreate the tree, or use your own custom AST
types.  (See <a class="reference" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#custom-code-generation">Custom Code Generation</a>, below.)</p>
<p>Note that you can disable folding using the <tt class="literal"><span class="pre">fold=False</span></tt> keyword argument to
<tt class="literal"><span class="pre">Call</span></tt>, if you want to ensure that even compile-time constants are computed
at runtime.  Compare:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( Call(Const(type), [1]) )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (&lt;type 'int'&gt;)

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( Call(Const(type), [1], fold=False) )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (&lt;type 'type'&gt;)
              3 LOAD_CONST               2 (1)
              6 CALL_FUNCTION            1
</pre>
<p>Folding is also <em>automatically</em> disabled for calls with no arguments of any
kind (such as <tt class="literal"><span class="pre">globals()</span></tt> or <tt class="literal"><span class="pre">locals()</span></tt>), whose values are much more likely
to change dynamically at runtime:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( Call(Const(locals)) )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (&lt;built-in function locals&gt;)
              3 CALL_FUNCTION            0
</pre>
<p>Note, however, that folding is disabled for <em>any</em> zero-argument call,
regardless of the thing being called.  It is not specific to <tt class="literal"><span class="pre">locals()</span></tt> and
<tt class="literal"><span class="pre">globals()</span></tt>, in other words.</p>
</div>
<div class="section" id="logical-and-or">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id25" name="logical-and-or">Logical And/Or</a></h3>
<p>You can evaluate logical and/or expressions using the <tt class="literal"><span class="pre">And</span></tt> and <tt class="literal"><span class="pre">Or</span></tt> node
types:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import And, Or

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_( And([Local('x'), Local('y')]) )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (x)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_FAST                1 (y)
        L1:     RETURN_VALUE

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_( Or([Local('x'), Local('y')]) )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (x)
                JUMP_IF_TRUE            L1
                POP_TOP
                LOAD_FAST                1 (y)
        L1:     RETURN_VALUE
</pre>
<p>True or false constants are folded automatically, avoiding code generation
for intermediate values that will never be used in the result:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_( And([1, 2, Local('y')]) )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_FAST                0 (y)
              3 RETURN_VALUE

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_( And([1, 2, Local('y'), 0]) )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (y)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_CONST               1 (0)
        L1:     RETURN_VALUE

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_( Or([1, 2, Local('y')]) )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (1)
              3 RETURN_VALUE

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_( Or([False, Local('y'), 3]) )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (y)
                JUMP_IF_TRUE            L1
                POP_TOP
                LOAD_CONST               1 (3)
        L1:     RETURN_VALUE
</pre>
</div>
</div>
<div class="section" id="custom-code-generation">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id26" name="custom-code-generation">Custom Code Generation</a></h2>
<p>Code generation is extensible: you can use any callable as a code-generation
target.  It will be called with exactly one argument: the code object.  It can
then perform whatever operations are desired.</p>
<p>In the most trivial case, you can use any unbound <tt class="literal"><span class="pre">Code</span></tt> method as a code
generation target, e.g.:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_GLOBAL('foo')
&gt;&gt;&gt; c(Call(Code.DUP_TOP, ()))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_GLOBAL              0 (foo)
              3 DUP_TOP
              4 CALL_FUNCTION            0
</pre>
<p>As you can see, the <tt class="literal"><span class="pre">Code.DUP_TOP()</span></tt> is called on the code instance, causing
a <tt class="literal"><span class="pre">DUP_TOP</span></tt> opcode to be output.  This is sometimes a handy trick for
accessing values that are already on the stack.  More commonly, however, you'll
want to implement more sophisticated callables.</p>
<p>To make it easy to create diverse target types, a <tt class="literal"><span class="pre">nodetype()</span></tt> decorator is
provided:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import nodetype
</pre>
<p>It allows you to create code generation target types using functions.  Your
function should take one or more arguments, with a <tt class="literal"><span class="pre">code=None</span></tt> optional
argument in the last position.  It should check whether <tt class="literal"><span class="pre">code</span> <span class="pre">is</span> <span class="pre">None</span></tt> when
called, and if so, return a tuple of the preceding arguments.  If <tt class="literal"><span class="pre">code</span></tt>
is not <tt class="literal"><span class="pre">None</span></tt>, then it should do whatever code generating tasks are required.
For example:</p>
<pre class="literal-block">&gt;&gt;&gt; def TryFinally(block1, block2, code=None):
...     if code is None:
...         return block1, block2
...     code(
...         Code.SETUP_FINALLY,
...             block1,
...         Code.POP_BLOCK,
...             block2,
...         Code.END_FINALLY
...     )
&gt;&gt;&gt; TryFinally = nodetype()(TryFinally)
</pre>
<p>Note: although the nodetype() generator can be used above the function
definition in either Python 2.3 or 2.4, it cannot be done in a doctest under
Python 2.3, so this document doesn't attempt to demonstrate that.  Under
2.4, you would do something like this:</p>
<pre class="literal-block">@nodetype()
def TryFinally(...):
</pre>
<p>and code that needs to also work under 2.3 should do something like this:</p>
<pre class="literal-block">nodetype()
def TryFinally(...):
</pre>
<p>But to keep the examples here working with doctest, we'll be doing our
<tt class="literal"><span class="pre">nodetype()</span></tt> calls after the end of the function definitions, e.g.:</p>
<pre class="literal-block">&gt;&gt;&gt; def ExprStmt(value, code=None):
...     if code is None:
...         return value,
...     code( value, Code.POP_TOP )
&gt;&gt;&gt; ExprStmt = nodetype()(ExprStmt)

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( TryFinally(ExprStmt(1), ExprStmt(2)) )
&gt;&gt;&gt; dump(c.code())
                SETUP_FINALLY           L1
                LOAD_CONST               1 (1)
                POP_TOP
                POP_BLOCK
                LOAD_CONST               0 (None)
        L1:     LOAD_CONST               2 (2)
                POP_TOP
                END_FINALLY
</pre>
<p>The <tt class="literal"><span class="pre">nodetype()</span></tt> decorator is virtually identical to the <tt class="literal"><span class="pre">struct()</span></tt>
decorator in the DecoratorTools package, except that it does not support
<tt class="literal"><span class="pre">*args</span></tt>, does not create a field for the <tt class="literal"><span class="pre">code</span></tt> argument, and generates a
<tt class="literal"><span class="pre">__call__()</span></tt> method that reinvokes the wrapped function to do the actual
code generation.</p>
<p>Among the benefits of this decorator are:</p>
<ul>
<li><p class="first">It gives your node types a great debugging format:</p>
<pre class="literal-block">&gt;&gt;&gt; tf = TryFinally(ExprStmt(1), ExprStmt(2))
&gt;&gt;&gt; tf
TryFinally(ExprStmt(1), ExprStmt(2))
</pre>
</li>
<li><p class="first">It makes named fields accessible:</p>
<pre class="literal-block">&gt;&gt;&gt; tf.block1
ExprStmt(1)

&gt;&gt;&gt; tf.block2
ExprStmt(2)
</pre>
</li>
<li><p class="first">Hashing and comparison work as expected (handy for algorithms that require
comparing or caching AST subtrees, such as common subexpression
elimination):</p>
<pre class="literal-block">&gt;&gt;&gt; ExprStmt(1) == ExprStmt(1)
True
&gt;&gt;&gt; ExprStmt(1) == ExprStmt(2)
False
</pre>
</li>
</ul>
<p>Please see the <a class="reference" href="http://peak.telecommunity.com/DevCenter/DecoratorTools#the-struct-decorator">struct decorator documentation</a> for info on how to customize
node types further.</p>
<p>Note: hashing only works if all the values you return in your argument tuple
are hashable, so you should try to convert them if possible.  For example, if
an argument accepts any sequence, you should probably convert it to a tuple
before returning it.  Most of the examples in this document, and the node types
supplied by <tt class="literal"><span class="pre">peak.util.assembler</span></tt> itself do this.</p>
<div class="section" id="constant-folding-in-custom-targets">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id27" name="constant-folding-in-custom-targets">Constant Folding in Custom Targets</a></h3>
<p>If you want to incorporate constant-folding into your AST nodes, you can do
so by checking for constant values and folding them at either construction
or code generation time.  For example, this <tt class="literal"><span class="pre">And</span></tt> node type (a simpler
version of the one included in <tt class="literal"><span class="pre">peak.util.assembler</span></tt>) folds constants during
code generation, by not generating unnecessary branches when it can
prove which way a branch will go:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import NotAConstant

&gt;&gt;&gt; def And(values, code=None):
...     if code is None:
...         return tuple(values),
...     end = Label()
...     for value in values[:-1]:
...         try:
...             if const_value(value):
...                 continue        # true constants can be skipped
...         except NotAConstant:    # but non-constants require code
...             code(value, end.JUMP_IF_FALSE_OR_POP)
...         else:       # and false constants end the chain right away
...             return code(value, end)
...     code(values[-1], end)
&gt;&gt;&gt; And = nodetype()(And)

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_( And([1, 2]) )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (2)
              3 RETURN_VALUE

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_( And([1, 2, Local('x')]) )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_FAST                0 (x)
              3 RETURN_VALUE

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_( And([Local('x'), False, 27]) )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (x)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_CONST               1 (False)
        L1:     RETURN_VALUE
</pre>
<p>The above example only folds constants at code generation time, however.  You
can also do constant folding at AST construction time, using the
<tt class="literal"><span class="pre">fold_args()</span></tt> function.  For example:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import fold_args

&gt;&gt;&gt; def Getattr(ob, name, code=None):
...     try:
...         name = const_value(name)
...     except NotAConstant:
...         return Call(Const(getattr), [ob, name])
...     if code is None:
...         return fold_args(Getattr, ob, name)
...     code(ob)
...     code.LOAD_ATTR(name)
&gt;&gt;&gt; Getattr = nodetype()(Getattr)

&gt;&gt;&gt; const_value(Getattr(1, '__class__'))
&lt;type 'int'&gt;
</pre>
<p>The <tt class="literal"><span class="pre">fold_args()</span></tt> function tries to evaluate the node immediately, if all of
its arguments are constants, by creating a temporary <tt class="literal"><span class="pre">Code</span></tt> object, and
running the supplied function against it, then doing an <tt class="literal"><span class="pre">eval()</span></tt> on the
generated code and wrapping the result in a <tt class="literal"><span class="pre">Const</span></tt>.  However, if any of the
arguments are non-constant, the original arguments (less the function) are
returned. This causes a normal node instance to be created instead of a
<tt class="literal"><span class="pre">Const</span></tt>.</p>
<p>This isn't a very <em>fast</em> way of doing partial evaluation, but it makes it
really easy to define new code generation targets without writing custom
constant-folding code for each one.  Just <tt class="literal"><span class="pre">return</span> <span class="pre">fold_args(ThisType,</span> <span class="pre">*args)</span></tt>
instead of <tt class="literal"><span class="pre">return</span> <span class="pre">args</span></tt>, if you want your node constructor to be able to do
eager evaluation.  If you need to, you can check your parameters in order to
decide whether to call <tt class="literal"><span class="pre">fold_args()</span></tt> or not; this is in fact how <tt class="literal"><span class="pre">Call</span></tt>
implements its <tt class="literal"><span class="pre">fold</span></tt> argument and the suppression of folding when
the call has no arguments.</p>
<p>(By the way, this same <tt class="literal"><span class="pre">Getattr</span></tt> node type is also available</p>
</div>
</div>
<div class="section" id="setting-the-code-s-calling-signature">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id28" name="setting-the-code-s-calling-signature">Setting the Code's Calling Signature</a></h2>
<p>The simplest way to set up the calling signature for a <tt class="literal"><span class="pre">Code</span></tt> instance is
to clone an existing function or code object's signature, using the
<tt class="literal"><span class="pre">Code.from_function()</span></tt> or <tt class="literal"><span class="pre">Code.from_code()</span></tt> classmethods.  These methods
create a new <tt class="literal"><span class="pre">Code</span></tt> instance whose calling signature (number and names of
arguments) matches that of the original function or code objects:</p>
<pre class="literal-block">&gt;&gt;&gt; def f1(a,b,*c,**d):
...     pass

&gt;&gt;&gt; c = Code.from_function(f1)
&gt;&gt;&gt; f2 = new.function(c.code(), globals())

&gt;&gt;&gt; import inspect

&gt;&gt;&gt; tuple(inspect.getargspec(f1))
(['a', 'b'], 'c', 'd', None)

&gt;&gt;&gt; tuple(inspect.getargspec(f2))
(['a', 'b'], 'c', 'd', None)
</pre>
<p>Note that these constructors do not copy any actual <em>code</em> from the code
or function objects.  They simply copy the signature, and, if you set the
<tt class="literal"><span class="pre">copy_lineno</span></tt> keyword argument to a true value, they will also set the
created code object's <tt class="literal"><span class="pre">co_firstlineno</span></tt> to match that of the original code or
function object:</p>
<pre class="literal-block">&gt;&gt;&gt; c1 = Code.from_function(f1, copy_lineno=True)
&gt;&gt;&gt; c1.co_firstlineno
1
&gt;&gt;&gt; c1.co_filename is f1.func_code.co_filename
True
</pre>
<p>If you create a <tt class="literal"><span class="pre">Code</span></tt> instance from a function that has nested positional
arguments, the returned code object will include a prologue to unpack the
arguments properly:</p>
<pre class="literal-block">&gt;&gt;&gt; def f3(a, (b,c), (d,(e,f))):
...     pass

&gt;&gt;&gt; f4 = new.function(Code.from_function(f3).code(), globals())
&gt;&gt;&gt; dis(f4)
  0           0 LOAD_FAST                1 (.1)
              3 UNPACK_SEQUENCE          2
              6 STORE_FAST               3 (b)
              9 STORE_FAST               4 (c)
             12 LOAD_FAST                2 (.2)
             15 UNPACK_SEQUENCE          2
             18 STORE_FAST               5 (d)
             21 UNPACK_SEQUENCE          2
             24 STORE_FAST               6 (e)
             27 STORE_FAST               7 (f)
</pre>
<p>This is roughly the same code that Python would generate to do the same
unpacking process, and is designed so that the <tt class="literal"><span class="pre">inspect</span></tt> module will
recognize it as an argument unpacking prologue:</p>
<pre class="literal-block">&gt;&gt;&gt; tuple(inspect.getargspec(f3))
(['a', ['b', 'c'], ['d', ['e', 'f']]], None, None, None)

&gt;&gt;&gt; tuple(inspect.getargspec(f4))
(['a', ['b', 'c'], ['d', ['e', 'f']]], None, None, None)
</pre>
<p>You can also use the <tt class="literal"><span class="pre">from_spec(name='&lt;lambda&gt;',</span> <span class="pre">args=(),</span> <span class="pre">var=None,</span> <span class="pre">kw=None)</span></tt>
classmethod to explicitly set a name and argument spec for a new code object:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code.from_spec('a', ('b', ('c','d'), 'e'), 'f', 'g')
&gt;&gt;&gt; c.co_name
'a'

&gt;&gt;&gt; c.co_varnames
['b', '.1', 'e', 'f', 'g', 'c', 'd']

&gt;&gt;&gt; c.co_argcount
3

&gt;&gt;&gt; tuple(inspect.getargs(c.code()))
(['b', ['c', 'd'], 'e'], 'f', 'g')
</pre>
</div>
<div class="section" id="code-attributes">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id29" name="code-attributes">Code Attributes</a></h2>
<p><tt class="literal"><span class="pre">Code</span></tt> instances have a variety of attributes corresponding to either the
attributes of the Python code objects they generate, or to the current state
of code generation.</p>
<p>For example, the <tt class="literal"><span class="pre">co_argcount</span></tt> and <tt class="literal"><span class="pre">co_varnames</span></tt> attributes
correspond to those used in creating the code for a Python function.  If you
want your code to be a function, you can set them as follows:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_argcount = 3
&gt;&gt;&gt; c.co_varnames = ['a','b','c']

&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; c.RETURN_VALUE()

&gt;&gt;&gt; f = new.function(c.code(), globals())
&gt;&gt;&gt; f(1,2,3)
42

&gt;&gt;&gt; import inspect
&gt;&gt;&gt; tuple(inspect.getargspec(f))
(['a', 'b', 'c'], None, None, None)
</pre>
<p>Although Python code objects want <tt class="literal"><span class="pre">co_varnames</span></tt> to be a tuple, <tt class="literal"><span class="pre">Code</span></tt>
instances use a list, so that names can be added during code generation.  The
<tt class="literal"><span class="pre">.code()</span></tt> method automatically creates tuples where necessary.</p>
<p>Here are all of the <tt class="literal"><span class="pre">Code</span></tt> attributes you may want to read or write:</p>
<dl>
<dt>co_filename</dt>
<dd>A string representing the source filename for this code.  If it's an actual
filename, then tracebacks that pass through the generated code will display
lines from the file.  The default value is <tt class="literal"><span class="pre">'&lt;generated</span> <span class="pre">code&gt;'</span></tt>.</dd>
<dt>co_name</dt>
<dd>The name of the function, class, or other block that this code represents.
The default value is <tt class="literal"><span class="pre">'&lt;lambda&gt;'</span></tt>.</dd>
<dt>co_argcount</dt>
<dd>Number of positional arguments a function accepts; defaults to 0</dd>
<dt>co_varnames</dt>
<dd>A list of strings naming the code's local variables, beginning with its
positional argument names, followed by its <tt class="literal"><span class="pre">*</span></tt> and <tt class="literal"><span class="pre">**</span></tt> argument names,
if applicable, followed by any other local variable names.  These names
are used by the <tt class="literal"><span class="pre">LOAD_FAST</span></tt> and <tt class="literal"><span class="pre">STORE_FAST</span></tt> opcodes, and invoking
the <tt class="literal"><span class="pre">.LOAD_FAST(name)</span></tt> and <tt class="literal"><span class="pre">.STORE_FAST(name)</span></tt> methods of a code object
will automatically add the given name to this list, if it's not already
present.</dd>
<dt>co_flags</dt>
<dd><p class="first">The flags for the Python code object.  This defaults to
<tt class="literal"><span class="pre">CO_OPTIMIZED</span> <span class="pre">|</span> <span class="pre">CO_NEWLOCALS</span></tt>, which is the correct value for a function
using "fast" locals.  This value is automatically or-ed with <tt class="literal"><span class="pre">CO_NOFREE</span></tt>
when generating a code object, if the <tt class="literal"><span class="pre">co_cellvars</span></tt> and <tt class="literal"><span class="pre">co_freevars</span></tt>
attributes are empty.  And if you use the <tt class="literal"><span class="pre">LOAD_NAME()</span></tt>,
<tt class="literal"><span class="pre">STORE_NAME()</span></tt>, or <tt class="literal"><span class="pre">DELETE_NAME()</span></tt> methods, the <tt class="literal"><span class="pre">CO_OPTIMIZED</span></tt> bit
is automatically reset, since these opcodes can only be used when the
code is running with a real (i.e. not virtualized) <tt class="literal"><span class="pre">locals()</span></tt> dictionary.</p>
<p class="last">If you need to change any other flag bits besides the above, you'll need to
set or clear them manually.  For your convenience, the
<tt class="literal"><span class="pre">peak.util.assembler</span></tt> module exports all the <tt class="literal"><span class="pre">CO_</span></tt> constants used by
Python.  For example, you can use <tt class="literal"><span class="pre">CO_VARARGS</span></tt> and <tt class="literal"><span class="pre">CO_VARKEYWORDS</span></tt> to
indicate whether a function accepts <tt class="literal"><span class="pre">*</span></tt> or <tt class="literal"><span class="pre">**</span></tt> arguments, as long as
you extend the <tt class="literal"><span class="pre">co_varnames</span></tt> list accordingly.  (Assuming you don't have
an existing function or code object with the desired signature, in which
case you could just use the <tt class="literal"><span class="pre">from_function()</span></tt> or <tt class="literal"><span class="pre">from_code()</span></tt>
classmethods instead of messing with these low-level attributes and flags.)</p>
</dd>
<dt>stack_size</dt>
<dd><p class="first">The predicted height of the runtime value stack, as of the current opcode.
Its value is automatically updated by most opcodes, but if you are doing
something sufficiently tricky (as in the <tt class="literal"><span class="pre">Switch</span></tt> demo, below) you may
need to explicitly set it.</p>
<p class="last">The <tt class="literal"><span class="pre">stack_size</span></tt> automatically becomes <tt class="literal"><span class="pre">None</span></tt> after any unconditional
jump operations, such as <tt class="literal"><span class="pre">JUMP_FORWARD</span></tt>, <tt class="literal"><span class="pre">BREAK_LOOP</span></tt>, or
<tt class="literal"><span class="pre">RETURN_VALUE</span></tt>.  When the stack size is <tt class="literal"><span class="pre">None</span></tt>, the only operations
that can be performed are the resolving of forward references (which will
set the stack size to what it was when the reference was created), or
manually setting the stack size.</p>
</dd>
<dt>co_freevars</dt>
<dd>A tuple of strings naming a function's "free" variables.  Defaults to an
empty tuple.  A function's free variables are the variables it "inherits"
from its surrounding scope.  If you're going to use this, you should set
it only once, before generating any code that references any free <em>or</em> cell
variables.</dd>
<dt>co_cellvars</dt>
<dd>A tuple of strings naming a function's "cell" variables.  Defaults to an
empty tuple.  A function's cell variables are the variables that are
"inherited" by one or more of its nested functions.  If you're going to use
this, you should set it only once, before generating any code that
references any free <em>or</em> cell variables.</dd>
</dl>
<p>These other attributes are automatically generated and maintained, so you'll
probably never have a reason to change them:</p>
<dl>
<dt>co_consts</dt>
<dd>A list of constants used by the code; the first (zeroth?) constant is
always <tt class="literal"><span class="pre">None</span></tt>.  Normally, this is automatically maintained; the
<tt class="literal"><span class="pre">.LOAD_CONST(value)</span></tt> method checks to see if the constant is already
present in this list, and adds it if it is not there.</dd>
<dt>co_names</dt>
<dd>A list of non-optimized or global variable names.  It's automatically
updated whenever you invoke a method to generate an opcode that uses
such names.</dd>
<dt>co_code</dt>
<dd>A byte array containing the generated code.  Don't mess with this.</dd>
<dt>co_firstlineno</dt>
<dd>The first line number of the generated code.  It automatically gets set
if you call <tt class="literal"><span class="pre">.set_lineno()</span></tt> before generating any code; otherwise it
defaults to zero.</dd>
<dt>co_lnotab</dt>
<dd>A byte array containing a generated line number table.  It's automatically
generated, so don't mess with it.</dd>
<dt>co_stacksize</dt>
<dd>The maximum amount of stack space the code will require to run.  This
value is updated automatically as you generate code or change
the <tt class="literal"><span class="pre">stack_size</span></tt> attribute.</dd>
</dl>
</div>
<div class="section" id="stack-size-tracking-and-dead-code-detection">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id30" name="stack-size-tracking-and-dead-code-detection">Stack Size Tracking and Dead Code Detection</a></h2>
<p><tt class="literal"><span class="pre">Code</span></tt> objects automatically track the predicted stack size as code is
generated, by updating the <tt class="literal"><span class="pre">stack_size</span></tt> attribute as each operation occurs.
A history is kept so that backward jumps can be checked to ensure that the
current stack height is the same as at the jump's target.  Similarly, when
forward jumps are resolved, the stack size at the jump target is checked
against the stack size at the jump's origin.  If there are multiple jumps to
the same location, they must all have the same stack size at the origin and
the destination.</p>
<p>In addition, whenever any unconditional jump code is generated (i.e.
<tt class="literal"><span class="pre">JUMP_FORWARD</span></tt>, <tt class="literal"><span class="pre">BREAK_LOOP</span></tt>, <tt class="literal"><span class="pre">CONTINUE_LOOP</span></tt>, <tt class="literal"><span class="pre">JUMP_ABSOLUTE</span></tt>, or
<tt class="literal"><span class="pre">RETURN_VALUE</span></tt>), the predicted <tt class="literal"><span class="pre">stack_size</span></tt> is set to <tt class="literal"><span class="pre">None</span></tt>.  This
means that the <tt class="literal"><span class="pre">Code</span></tt> object does not know what the stack size will be at
the current location.  You cannot issue <em>any</em> instructions when the predicted
stack size is <tt class="literal"><span class="pre">None</span></tt>, as you will receive an <tt class="literal"><span class="pre">AssertionError</span></tt>:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; fwd = c.JUMP_FORWARD()
&gt;&gt;&gt; print c.stack_size  # forward jump marks stack size as unknown
None

&gt;&gt;&gt; c.LOAD_CONST(42)
Traceback (most recent call last):
  ...
AssertionError: Unknown stack size at this location
</pre>
<p>Instead, you must resolve a forward reference (or define a previously-jumped to
label).  This will propagate the stack size at the source of the jump to the
current location, updating the stack size:</p>
<pre class="literal-block">&gt;&gt;&gt; fwd()
&gt;&gt;&gt; c.stack_size
0
</pre>
<p>Note, by the way, that this means it is impossible for you to generate static
"dead code".  In other words, you cannot generate code that isn't reachable.
You should therefore check if <tt class="literal"><span class="pre">stack_size</span></tt> is <tt class="literal"><span class="pre">None</span></tt> before generating
code that might be unreachable.  For example, consider this <tt class="literal"><span class="pre">If</span></tt>
implementation:</p>
<pre class="literal-block">&gt;&gt;&gt; def If(cond, then, else_=Pass, code=None):
...     if code is None:
...         return cond, then, else_
...     else_clause = Label()
...     end_if = Label()
...     code(cond, else_clause.JUMP_IF_FALSE_OR_POP, then)
...     code(end_if.JUMP_FORWARD, else_clause, Code.POP_TOP, else_)
...     code(end_if)
&gt;&gt;&gt; If = nodetype()(If)
</pre>
<p>It works okay if there's no dead code:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( If(Local('a'), 42, 55) )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (a)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_CONST               1 (42)
                JUMP_FORWARD            L2
        L1:     POP_TOP
                LOAD_CONST               2 (55)
</pre>
<p>But it breaks if you end the "then" block with a return:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( If(23, Return(42), 55) )
Traceback (most recent call last):
  ...
AssertionError: Unknown stack size at this location
</pre>
<p>What we need is something like this instead:</p>
<pre class="literal-block">&gt;&gt;&gt; def If(cond, then, else_=Pass, code=None):
...     if code is None:
...         return cond, then, else_
...     else_clause = Label()
...     end_if = Label()
...     code(cond, else_clause.JUMP_IF_FALSE_OR_POP, then)
...     if code.stack_size is not None:
...         end_if.JUMP_FORWARD(code)
...     code(else_clause, Code.POP_TOP, else_, end_if)
&gt;&gt;&gt; If = nodetype()(If)
</pre>
<p>As you can see, the dead code is now eliminated:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( If(Local('a'), Return(42), 55) )
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (a)
                JUMP_IF_FALSE           L1
                POP_TOP
                LOAD_CONST               1 (42)
                RETURN_VALUE
        L1:     POP_TOP
                LOAD_CONST               2 (55)
</pre>
</div>
<div class="section" id="blocks-loops-and-exception-handling">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id31" name="blocks-loops-and-exception-handling">Blocks, Loops, and Exception Handling</a></h2>
<p>The Python <tt class="literal"><span class="pre">SETUP_FINALLY</span></tt>, <tt class="literal"><span class="pre">SETUP_EXCEPT</span></tt>, and <tt class="literal"><span class="pre">SETUP_LOOP</span></tt> opcodes
all create "blocks" that go on the frame's "block stack" at runtime.  Each of
these opcodes <em>must</em> be matched with <em>exactly one</em> <tt class="literal"><span class="pre">POP_BLOCK</span></tt> opcode -- no
more, and no less.  <tt class="literal"><span class="pre">Code</span></tt> objects enforce this using an internal block stack
that matches each setup with its corresponding <tt class="literal"><span class="pre">POP_BLOCK</span></tt>.  Trying to pop
a nonexistent block, or trying to generate code when unclosed blocks exist is
an error:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.POP_BLOCK()
Traceback (most recent call last):
  ...
AssertionError: Not currently in a block

&gt;&gt;&gt; c.SETUP_FINALLY()
&gt;&gt;&gt; c.code()
Traceback (most recent call last):
  ...
AssertionError: 1 unclosed block(s)

&gt;&gt;&gt; c.POP_BLOCK()
&gt;&gt;&gt; c.code()
&lt;code object &lt;lambda&gt; ...&gt;
</pre>
<div class="section" id="exception-stack-size-adjustment">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id32" name="exception-stack-size-adjustment">Exception Stack Size Adjustment</a></h3>
<p>When you issue a <tt class="literal"><span class="pre">SETUP_EXCEPT</span></tt> or <tt class="literal"><span class="pre">SETUP_FINALLY</span></tt>, the code's maximum
stack size is raised to ensure that it's at least 3 items higher than
the current stack size.  That way, there will be room for the items that Python
puts on the stack when jumping to a block's exception handling code:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.SETUP_FINALLY()
&gt;&gt;&gt; c.stack_size, c.co_stacksize
(0, 3)
</pre>
<p>As you can see, the current stack size is unchanged, but the maximum stack size
has increased.  This increase is relative to the current stack size, though;
it's not an absolute increase:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(1,2,3,4, *[Code.POP_TOP]*4)   # push 4 things, then pop 'em
&gt;&gt;&gt; c.SETUP_FINALLY()
&gt;&gt;&gt; c.stack_size, c.co_stacksize
(0, 4)
</pre>
<p>And this stack adjustment doesn't happen for loops, because they don't have
exception handlers:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.SETUP_LOOP()
&gt;&gt;&gt; c.stack_size, c.co_stacksize
(0, 0)
</pre>
</div>
<div class="section" id="try-except-blocks">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id33" name="try-except-blocks">Try/Except Blocks</a></h3>
<p>In the case of <tt class="literal"><span class="pre">SETUP_EXCEPT</span></tt>, the <em>current</em> stack size is increased by 3
after a <tt class="literal"><span class="pre">POP_BLOCK</span></tt>, because the code that follows will be an exception
handler and will thus always have exception items on the stack:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.SETUP_EXCEPT()
&gt;&gt;&gt; else_ = c.POP_BLOCK()
&gt;&gt;&gt; c.stack_size, c.co_stacksize
(3, 3)
</pre>
<p>When a <tt class="literal"><span class="pre">POP_BLOCK()</span></tt> is matched with a <tt class="literal"><span class="pre">SETUP_EXCEPT</span></tt>, it automatically
emits a <tt class="literal"><span class="pre">JUMP_FORWARD</span></tt> and returns a forward reference that should be called
back when the "else" clause or end of the entire try/except statement is
reached:</p>
<pre class="literal-block">&gt;&gt;&gt; c.POP_TOP()     # get rid of exception info
&gt;&gt;&gt; c.POP_TOP()
&gt;&gt;&gt; c.POP_TOP()
&gt;&gt;&gt; else_()
&gt;&gt;&gt; c.return_()
&gt;&gt;&gt; dump(c.code())
                SETUP_EXCEPT            L1
                POP_BLOCK
                JUMP_FORWARD            L2
        L1:     POP_TOP
                POP_TOP
                POP_TOP
        L2:     LOAD_CONST               0 (None)
                RETURN_VALUE
</pre>
<p>In the example above, an empty block executes with an exception handler that
begins at offset 7.  When the block is done, it jumps forward to the end of
the try/except construct at offset 10.  The exception handler does nothing but
remove the exception information from the stack before it falls through to the
end.</p>
<p>Note, by the way, that it's usually easier to use labels to define blocks
like this:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; done = Label()
&gt;&gt;&gt; c(
...     done.SETUP_EXCEPT,
...     done.POP_BLOCK,
...         Code.POP_TOP, Code.POP_TOP, Code.POP_TOP,
...     done,
...     Return()
... )

&gt;&gt;&gt; dump(c.code())
                SETUP_EXCEPT             L1
                POP_BLOCK
                JUMP_FORWARD             L2
        L1:     POP_TOP
                POP_TOP
                POP_TOP
        L2:     LOAD_CONST               0 (None)
                RETURN_VALUE
</pre>
<p>(Labels have a <tt class="literal"><span class="pre">POP_BLOCK</span></tt> attribute that you can pass in when generating
code.)</p>
<p>And, for generating typical try/except blocks, you can use the <tt class="literal"><span class="pre">TryExcept</span></tt>
node type, which takes a body, a sequence of exception-type/handler pairs,
and an optional "else" clause:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import TryExcept
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_(
...     TryExcept(
...         Return(1),                                      # body
...         [(Const(KeyError),2), (Const(TypeError),3)],    # handlers
...         Return(4)                                       # else clause
...     )
... )

&gt;&gt;&gt; dump(c.code())
                SETUP_EXCEPT            L1
                LOAD_CONST               1 (1)
                RETURN_VALUE
                POP_BLOCK
                JUMP_FORWARD            L4
        L1:     DUP_TOP
                LOAD_CONST               2 (&lt;...exceptions.KeyError...&gt;)
                COMPARE_OP              10 (exception match)
                JUMP_IF_FALSE           L2
                POP_TOP
                POP_TOP
                POP_TOP
                POP_TOP
                LOAD_CONST               3 (2)
                JUMP_FORWARD            L5
        L2:     POP_TOP
                DUP_TOP
                LOAD_CONST               4 (&lt;...exceptions.TypeError...&gt;)
                COMPARE_OP              10 (exception match)
                JUMP_IF_FALSE           L3
                POP_TOP
                POP_TOP
                POP_TOP
                POP_TOP
                LOAD_CONST               5 (3)
                JUMP_FORWARD            L5
        L3:     POP_TOP
                END_FINALLY
        L4:     LOAD_CONST               6 (4)
                RETURN_VALUE
        L5:     RETURN_VALUE
</pre>
</div>
<div class="section" id="try-finally-blocks">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id34" name="try-finally-blocks">Try/Finally Blocks</a></h3>
<p>When a <tt class="literal"><span class="pre">POP_BLOCK()</span></tt> is matched with a <tt class="literal"><span class="pre">SETUP_FINALLY</span></tt>, it automatically
emits a <tt class="literal"><span class="pre">LOAD_CONST(None)</span></tt>, so that when the corresponding <tt class="literal"><span class="pre">END_FINALLY</span></tt>
is reached, it will know that the "try" block exited normally.  Thus, the
normal pattern for producing a try/finally construct is as follows:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.SETUP_FINALLY()
&gt;&gt;&gt; # "try" suite goes here
&gt;&gt;&gt; c.POP_BLOCK()
&gt;&gt;&gt; # "finally" suite goes here
&gt;&gt;&gt; c.END_FINALLY()
</pre>
<p>And it produces code that looks like this:</p>
<pre class="literal-block">&gt;&gt;&gt; dump(c.code())
                SETUP_FINALLY           L1
                POP_BLOCK
                LOAD_CONST               0 (None)
        L1:     END_FINALLY
</pre>
<p>The <tt class="literal"><span class="pre">END_FINALLY</span></tt> opcode will remove 1, 2, or 3 values from the stack at
runtime, depending on how the "try" block was exited.  In the case of simply
"falling off the end" of the "try" block, however, the inserted
<tt class="literal"><span class="pre">LOAD_CONST(None)</span></tt> puts one value on the stack, and that one value is popped
off by the <tt class="literal"><span class="pre">END_FINALLY</span></tt>.  For that reason, <tt class="literal"><span class="pre">Code</span></tt> objects treat
<tt class="literal"><span class="pre">END_FINALLY</span></tt> as if it always popped exactly one value from the stack, even
though at runtime this may vary.  This means that the estimated stack levels
within the "finally" clause may not be accurate -- which is why <tt class="literal"><span class="pre">POP_BLOCK()</span></tt>
adjusts the maximum expected stack size to accomodate up to three values being
put on the stack by the Python interpreter for exception handling.</p>
<p>For your convenience, the <tt class="literal"><span class="pre">TryFinally</span></tt> node type can also be used to generate
try/finally blocks:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import TryFinally
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c( TryFinally(ExprStmt(1), ExprStmt(2)) )
&gt;&gt;&gt; dump(c.code())
                SETUP_FINALLY           L1
                LOAD_CONST               1 (1)
                POP_TOP
                POP_BLOCK
                LOAD_CONST               0 (None)
        L1:     LOAD_CONST               2 (2)
                POP_TOP
                END_FINALLY
</pre>
</div>
<div class="section" id="loops">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id35" name="loops">Loops</a></h3>
<p>The <tt class="literal"><span class="pre">POP_BLOCK</span></tt> for a loop marks the end of the loop body, and the beginning
of the "else" clause, if there is one.  It returns a forward reference that
should be called back either at the end of the "else" clause, or immediately if
there is no "else".  Any <tt class="literal"><span class="pre">BREAK_LOOP</span></tt> opcodes that appear in the loop body
will jump ahead to the point at which the forward reference is resolved.</p>
<p>Here, we'll generate a loop that counts down from 5 to 0, with an "else" clause
that returns 42.  Three labels are needed: one to mark the end of the overall
block, one that's looped back to, and one that marks the "else" clause:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; block = Label()
&gt;&gt;&gt; loop = Label()
&gt;&gt;&gt; else_ = Label()
&gt;&gt;&gt; c(
...     block.SETUP_LOOP,
...         5,      # initial setup - this could be a GET_ITER instead
...     loop,
...         else_.JUMP_IF_FALSE,        # while x:
...         1, Code.BINARY_SUBTRACT,    #     x -= 1
...         loop.CONTINUE_LOOP,
...     else_,                          # else:
...         Code.POP_TOP,
...     block.POP_BLOCK,
...         Return(42),                 #     return 42
...     block,
...     Return()
... )

&gt;&gt;&gt; dump(c.code())
                SETUP_LOOP              L3
                LOAD_CONST               1 (5)
        L1:     JUMP_IF_FALSE           L2
                LOAD_CONST               2 (1)
                BINARY_SUBTRACT
                JUMP_ABSOLUTE           L1
        L2:     POP_TOP
                POP_BLOCK
                LOAD_CONST               3 (42)
                RETURN_VALUE
        L3:     LOAD_CONST               0 (None)
                RETURN_VALUE

&gt;&gt;&gt; eval(c.code())
42
</pre>
</div>
<div class="section" id="break-and-continue">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id36" name="break-and-continue">Break and Continue</a></h3>
<p>The <tt class="literal"><span class="pre">BREAK_LOOP</span></tt> and <tt class="literal"><span class="pre">CONTINUE_LOOP</span></tt> opcodes can only be used inside of
an active loop:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.BREAK_LOOP()
Traceback (most recent call last):
  ...
AssertionError: Not inside a loop

&gt;&gt;&gt; c.CONTINUE_LOOP(c.here())
Traceback (most recent call last):
  ...
AssertionError: Not inside a loop
</pre>
<p>And <tt class="literal"><span class="pre">CONTINUE_LOOP</span></tt> is automatically replaced with a <tt class="literal"><span class="pre">JUMP_ABSOLUTE</span></tt> if
it occurs directly inside a loop block:</p>
<pre class="literal-block">&gt;&gt;&gt; c.LOAD_CONST(57)
&gt;&gt;&gt; c.SETUP_LOOP()
&gt;&gt;&gt; fwd = c.JUMP_IF_TRUE()
&gt;&gt;&gt; c.CONTINUE_LOOP(c.here())
&gt;&gt;&gt; fwd()
&gt;&gt;&gt; c.BREAK_LOOP()
&gt;&gt;&gt; c.POP_BLOCK()()
&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 (57)
                SETUP_LOOP              L3
                JUMP_IF_TRUE            L2
        L1:     JUMP_ABSOLUTE           L1
        L2:     BREAK_LOOP
                POP_BLOCK
</pre>
<p>In other words, <tt class="literal"><span class="pre">CONTINUE_LOOP</span></tt> only really emits a <tt class="literal"><span class="pre">CONTINUE_LOOP</span></tt> opcode
if it's inside some other kind of block within the loop, e.g. a "try" clause:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(57)
&gt;&gt;&gt; c.SETUP_LOOP()
&gt;&gt;&gt; loop = c.here()
&gt;&gt;&gt; c.SETUP_FINALLY()
&gt;&gt;&gt; fwd = c.JUMP_IF_TRUE()
&gt;&gt;&gt; c.CONTINUE_LOOP(loop)
&gt;&gt;&gt; fwd()
&gt;&gt;&gt; c.POP_BLOCK()
&gt;&gt;&gt; c.END_FINALLY()
&gt;&gt;&gt; c.POP_BLOCK()()
&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 (57)
                SETUP_LOOP              L4
        L1:     SETUP_FINALLY           L3
                JUMP_IF_TRUE            L2
                CONTINUE_LOOP           L1
        L2:     POP_BLOCK
                LOAD_CONST               0 (None)
        L3:     END_FINALLY
                POP_BLOCK
</pre>
</div>
<div class="section" id="for-loops">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id37" name="for-loops"><tt class="literal"><span class="pre">for</span></tt> Loops</a></h3>
<p>There is a <tt class="literal"><span class="pre">For()</span></tt> node type available for generating simple loops (without
break/continue support).  It takes an iterable expression, an assignment
clause, and a loop body:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import For
&gt;&gt;&gt; y = Call(Const(range), (3,))
&gt;&gt;&gt; x = LocalAssign('x')
&gt;&gt;&gt; body = Suite([Local('x'), Code.PRINT_EXPR])

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(For(y, x, body))  # for x in range(3): print x
&gt;&gt;&gt; c.return_()
&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 ([0, 1, 2])
                GET_ITER
        L1:     FOR_ITER                L2
                STORE_FAST               0 (x)
                LOAD_FAST                0 (x)
                PRINT_EXPR
                JUMP_ABSOLUTE           L1
        L2:     LOAD_CONST               0 (None)
                RETURN_VALUE
</pre>
<p>The arguments are given in execution order: first the "in" value of the loop,
then the assignment to a loop variable, and finally the body of the loop.  The
distinction between the assignment and body, however, is only for clarity and
convenience (to avoid needing to glue the assignment to the body with a
<tt class="literal"><span class="pre">Suite</span></tt>).  If you already have a suite or only need one node for the entire
loop body, you can do the same thing with only two arguments:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(For(y, Code.PRINT_EXPR))
&gt;&gt;&gt; c.return_()
&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 ([0, 1, 2])
                GET_ITER
        L1:     FOR_ITER                L2
                PRINT_EXPR
                JUMP_ABSOLUTE           L1
        L2:     LOAD_CONST               0 (None)
                RETURN_VALUE
</pre>
<p>Notice, by the way, that <tt class="literal"><span class="pre">For()</span></tt> does NOT set up a loop block for you, so if
you want to be able to use break and continue, you'll need to wrap the loop in
a labelled SETUP_LOOP/POP_BLOCK pair, as described in the preceding sections.</p>
</div>
<div class="section" id="list-comprehensions">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id38" name="list-comprehensions">List Comprehensions</a></h3>
<p>In order to generate correct list comprehension code for the target Python
version, you must use the <tt class="literal"><span class="pre">ListComp()</span></tt> and <tt class="literal"><span class="pre">LCAppend()</span></tt> node types.  This
is because Python versions 2.4 and up store the list being built in a temporary
variable, and use a special <tt class="literal"><span class="pre">LIST_APPEND</span></tt> opcode to append values, while 2.3
stores the list's <tt class="literal"><span class="pre">append()</span></tt> method in the temporary variable, and calls it
to append values.</p>
<p>The <tt class="literal"><span class="pre">ListComp()</span></tt> node wraps a code body (usually a <tt class="literal"><span class="pre">For()</span></tt> loop) and
manages the creation and destruction of a temporary variable (e.g. <tt class="literal"><span class="pre">_[1]</span></tt>,
<tt class="literal"><span class="pre">_[2]</span></tt>, etc.).  The <tt class="literal"><span class="pre">LCAppend()</span></tt> node type wraps a value or expression to
be appended to the innermost active <tt class="literal"><span class="pre">ListComp()</span></tt> in progress:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import ListComp, LCAppend
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; simple = ListComp(For(y, x, LCAppend(Local('x'))))
&gt;&gt;&gt; c.return_(simple)
&gt;&gt;&gt; eval(c.code())
[0, 1, 2]

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_(ListComp(For(y, x, LCAppend(simple))))
&gt;&gt;&gt; eval(c.code())
[[0, 1, 2], [0, 1, 2], [0, 1, 2]]
</pre>
</div>
</div>
<div class="section" id="closures-and-nested-functions">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id39" name="closures-and-nested-functions">Closures and Nested Functions</a></h2>
<div class="section" id="free-and-cell-variables">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id40" name="free-and-cell-variables">Free and Cell Variables</a></h3>
<p>To implement closures and nested scopes, your code objects must use "free" or
"cell" variables in place of regular "fast locals".  A "free" variable is one
that is defined in an outer scope, and a "cell" variable is one that's defined
in the current scope, but will also be used by nested functions.</p>
<p>The simplest way to set up free or cell variables is to use a code object's
<tt class="literal"><span class="pre">makefree(names)</span></tt> and <tt class="literal"><span class="pre">makecells(names)</span></tt> methods:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_cellvars
()
&gt;&gt;&gt; c.co_freevars
()

&gt;&gt;&gt; c.makefree(['x', 'y'])
&gt;&gt;&gt; c.makecells(['z'])

&gt;&gt;&gt; c.co_cellvars
('z',)
&gt;&gt;&gt; c.co_freevars
('x', 'y')
</pre>
<p>When a name has been defined as a free or cell variable, the <tt class="literal"><span class="pre">_DEREF</span></tt> opcode
variants are used to generate <tt class="literal"><span class="pre">Local()</span></tt> and <tt class="literal"><span class="pre">LocalAssign()</span></tt> nodes:</p>
<pre class="literal-block">&gt;&gt;&gt; c((Local('x'), Local('y')), LocalAssign('z'))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_DEREF               1 (x)
              3 LOAD_DEREF               2 (y)
              6 BUILD_TUPLE              2
              9 STORE_DEREF              0 (z)
</pre>
<p>If you have already written code in a code object that operates on the relevant
locals, the code is retroactively patched to use the <tt class="literal"><span class="pre">_DEREF</span></tt> opcodes:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c((Local('x'), Local('y')), LocalAssign('z'))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BUILD_TUPLE              2
              9 STORE_FAST               2 (z)

&gt;&gt;&gt; c.makefree(['x', 'y'])
&gt;&gt;&gt; c.makecells(['z'])

&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_DEREF               1 (x)
              3 LOAD_DEREF               2 (y)
              6 BUILD_TUPLE              2
              9 STORE_DEREF              0 (z)
</pre>
<p>This means that you can defer the decision of which locals are free/cell
variables until the code is ready to be generated.  In fact, by passing in
a "parent" code object to the <tt class="literal"><span class="pre">.code()</span></tt> method, you can get BytecodeAssembler
to automatically call <tt class="literal"><span class="pre">makefree()</span></tt> and <tt class="literal"><span class="pre">makecells()</span></tt> for the correct
variable names in the child and parent code objects, as we'll see in the next
section.</p>
</div>
<div class="section" id="nested-code-objects">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id41" name="nested-code-objects">Nested Code Objects</a></h3>
<p>To create a code object for use in a nested scope, you can use the parent code
object's <tt class="literal"><span class="pre">nested()</span></tt> method.  It works just like the <tt class="literal"><span class="pre">from_spec()</span></tt>
classmethod, except that the <tt class="literal"><span class="pre">co_filename</span></tt> of the parent is copied to the
child:</p>
<pre class="literal-block">&gt;&gt;&gt; p = Code()
&gt;&gt;&gt; p.co_filename = 'testname'

&gt;&gt;&gt; c = p.nested('sub', ['a','b'], 'c', 'd')

&gt;&gt;&gt; c.co_name
'sub'

&gt;&gt;&gt; c.co_filename
'testname'

&gt;&gt;&gt; tuple(inspect.getargs(c.code(p)))
(['a', 'b'], 'c', 'd')
</pre>
<p>Notice that you must pass the parent code object to the child's <tt class="literal"><span class="pre">.code()</span></tt>
method to ensure that free/cell variables are properly set up.  When the
<tt class="literal"><span class="pre">code()</span></tt> method is given another code object as a parameter, it automatically
converts any locally-read (but not written) to "free" variables in the child
code, and ensures that those same variables become "cell" variables in the
supplied parent code object:</p>
<pre class="literal-block">&gt;&gt;&gt; p.LOAD_CONST(42)
&gt;&gt;&gt; p(LocalAssign('a'))
&gt;&gt;&gt; dis(p.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_FAST               0 (a)

&gt;&gt;&gt; c = p.nested()
&gt;&gt;&gt; c(Local('a'))

&gt;&gt;&gt; dis(c.code(p))
  0           0 LOAD_DEREF               0 (a)

&gt;&gt;&gt; dis(p.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_DEREF              0 (a)
</pre>
<p>Notice that the <tt class="literal"><span class="pre">STORE_FAST</span></tt> in the parent code object was automatically
patched to a <tt class="literal"><span class="pre">STORE_DEREF</span></tt>, with an updated offset if applicable.  Any
future use of <tt class="literal"><span class="pre">Local('a')</span></tt> or <tt class="literal"><span class="pre">LocalAssign('a')</span></tt> in the parent or child
code objects will now refer to the free/cell variable, rather than the "local"
variable:</p>
<pre class="literal-block">&gt;&gt;&gt; p(Local('a'))
&gt;&gt;&gt; dis(p.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_DEREF              0 (a)
              6 LOAD_DEREF               0 (a)

&gt;&gt;&gt; c(LocalAssign('a'))
&gt;&gt;&gt; dis(c.code(p))
  0           0 LOAD_DEREF               0 (a)
              3 STORE_DEREF              0 (a)
</pre>
</div>
<div class="section" id="function">
<h3><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id42" name="function"><tt class="literal"><span class="pre">Function()</span></tt></a></h3>
<p>The <tt class="literal"><span class="pre">Function(body,</span> <span class="pre">name='&lt;lambda&gt;',</span> <span class="pre">args=(),</span> <span class="pre">var=None,</span> <span class="pre">kw=None,</span> <span class="pre">defaults=())</span></tt>
node type creates a function object from the specified body and the optional
name, argument specs, and defaults.  The <tt class="literal"><span class="pre">Function()</span></tt> node generates code to
create the function object with the appropriate defaults and closure (if
applicable), and any needed free/cell variables are automatically set up in the
parent and child code objects.  The newly generated function will be on top of
the stack at the end of the generated code:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import Function
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_filename = '&lt;string&gt;'
&gt;&gt;&gt; c.return_(Function(Return(Local('a')), 'f', ['a'], defaults=[42]))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 LOAD_CONST               2 (&lt;... f ..., file "&lt;string&gt;", line -1&gt;)
              6 MAKE_FUNCTION            1
              9 RETURN_VALUE
</pre>
<p>Now that we've generated the code for a function returning a function, let's
run it, to get the function we defined:</p>
<pre class="literal-block">&gt;&gt;&gt; f = eval(c.code())
&gt;&gt;&gt; f
&lt;function f at ...&gt;

&gt;&gt;&gt; tuple(inspect.getargspec(f))
(['a'], None, None, (42,))

&gt;&gt;&gt; f()
42

&gt;&gt;&gt; f(99)
99
</pre>
<p>Now let's create a doubly nested function, with some extras:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_filename = '&lt;string&gt;'
&gt;&gt;&gt; c.return_(
...     Function(Return(Function(Return(Local('a')))),
...     'f', ['a', 'b'], 'c', 'd', [99, 66])
... )
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (99)
              3 LOAD_CONST               2 (66)
              6 LOAD_CONST               3 (&lt;... f ..., file "&lt;string&gt;", line -1&gt;)
              9 MAKE_FUNCTION            2
             12 RETURN_VALUE

&gt;&gt;&gt; f = eval(c.code())
&gt;&gt;&gt; f
&lt;function f at ...&gt;

&gt;&gt;&gt; tuple(inspect.getargspec(f))
(['a', 'b'], 'c', 'd', (99, 66))

&gt;&gt;&gt; dis(f)
  0           0 LOAD_CLOSURE             0 (a)
              ... LOAD_CONST               1 (&lt;... &lt;lambda&gt; ..., file "&lt;string&gt;", line -1&gt;)
              ... MAKE_CLOSURE             0
              ... RETURN_VALUE

&gt;&gt;&gt; dis(f())
  0           0 LOAD_DEREF               0 (a)
              3 RETURN_VALUE

&gt;&gt;&gt; f(42)()
42

&gt;&gt;&gt; f()()
99
</pre>
<p>As you can see, <tt class="literal"><span class="pre">Function()</span></tt> not only takes care of setting up free/cell
variables in all the relevant scopes, it also chooses whether to use
<tt class="literal"><span class="pre">MAKE_FUNCTION</span></tt> or <tt class="literal"><span class="pre">MAKE_CLOSURE</span></tt>, and generates code for the defaults.</p>
<p>(Note, by the way, that the <cite>defaults</cite> argument should be a sequence of
generatable expressions; in the examples here, we used numbers, but they could
have been arbitrary expression nodes.)</p>
</div>
</div>
</div>
<div class="section" id="internals-and-doctests">
<h1><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id43" name="internals-and-doctests">Internals and Doctests</a></h1>
<p>Line number tracking:</p>
<pre class="literal-block">&gt;&gt;&gt; def simple_code(flno, slno, consts=1, ):
...     c = Code()
...     c.set_lineno(flno)
...     for i in range(consts): c.LOAD_CONST(None)
...     c.set_lineno(slno)
...     c.RETURN_VALUE()
...     return c.code()

&gt;&gt;&gt; dis(simple_code(1,1))
  1           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE

&gt;&gt;&gt; simple_code(1,1).co_stacksize
1

&gt;&gt;&gt; dis(simple_code(13,414))
 13           0 LOAD_CONST               0 (None)
414           3 RETURN_VALUE

&gt;&gt;&gt; dis(simple_code(13,14,100))
 13           0 LOAD_CONST               0 (None)
              3 LOAD_CONST               0 (None)
...
 14         300 RETURN_VALUE

&gt;&gt;&gt; simple_code(13,14,100).co_stacksize
100

&gt;&gt;&gt; dis(simple_code(13,572,120))
 13           0 LOAD_CONST               0 (None)
              3 LOAD_CONST               0 (None)
...
572         360 RETURN_VALUE
</pre>
<p>Stack size tracking:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()          # 0
&gt;&gt;&gt; c.LOAD_CONST(1)     # 1
&gt;&gt;&gt; c.POP_TOP()         # 0
&gt;&gt;&gt; c.LOAD_CONST(2)     # 1
&gt;&gt;&gt; c.LOAD_CONST(3)     # 2
&gt;&gt;&gt; c.co_stacksize
2
&gt;&gt;&gt; c.stack_history
[0, ..., 1, 0, ..., 1]
&gt;&gt;&gt; c.BINARY_ADD()      # 1
&gt;&gt;&gt; c.LOAD_CONST(4)     # 2
&gt;&gt;&gt; c.co_stacksize
2
&gt;&gt;&gt; c.stack_history
[0, ..., 1, 0, 1, ..., 2, ..., 1]
&gt;&gt;&gt; c.LOAD_CONST(5)
&gt;&gt;&gt; c.LOAD_CONST(6)
&gt;&gt;&gt; c.co_stacksize
4
&gt;&gt;&gt; c.POP_TOP()
&gt;&gt;&gt; c.stack_size
3
</pre>
<p>Stack underflow detection/recovery, and global/local variable names:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_GLOBAL('foo')
&gt;&gt;&gt; c.stack_size
1
&gt;&gt;&gt; c.STORE_ATTR('bar')     # drops stack by 2
Traceback (most recent call last):
  ...
AssertionError: Stack underflow

&gt;&gt;&gt; c.co_names  # 'bar' isn't added unless success
['foo']

&gt;&gt;&gt; c.LOAD_ATTR('bar')
&gt;&gt;&gt; c.co_names
['foo', 'bar']

&gt;&gt;&gt; c.DELETE_FAST('baz')
&gt;&gt;&gt; c.co_varnames
['baz']

&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_GLOBAL              0 (foo)
              3 LOAD_ATTR                1 (bar)
              6 DELETE_FAST              0 (baz)
</pre>
<p>Code iteration:</p>
<pre class="literal-block">&gt;&gt;&gt; c.DUP_TOP()
&gt;&gt;&gt; c.return_(Code.POP_TOP)
&gt;&gt;&gt; list(c) == [
...     (0, op.LOAD_GLOBAL, 0),
...     (3, op.LOAD_ATTR, 1),
...     (6, op.DELETE_FAST, 0),
...     (9, op.DUP_TOP, None),
...     (10, op.POP_TOP, None),
...     (11, op.RETURN_VALUE, None)
... ]
True
</pre>
<p>Code patching:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; c.STORE_FAST('x')
&gt;&gt;&gt; c.LOAD_FAST('x')
&gt;&gt;&gt; c.DELETE_FAST('x')
&gt;&gt;&gt; c.RETURN_VALUE()

&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_FAST               0 (x)
              6 LOAD_FAST                0 (x)
              9 DELETE_FAST              0 (x)
             12 RETURN_VALUE


&gt;&gt;&gt; c.co_varnames
['x']
&gt;&gt;&gt; c.co_varnames.append('y')

&gt;&gt;&gt; c._patch(
...     {op.LOAD_FAST:  op.LOAD_FAST,
...      op.STORE_FAST: op.STORE_FAST,
...      op.DELETE_FAST: op.DELETE_FAST},
...     {0: 1}
... )

&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_FAST               1 (y)
              6 LOAD_FAST                1 (y)
              9 DELETE_FAST              1 (y)
             12 RETURN_VALUE

&gt;&gt;&gt; c._patch({op.RETURN_VALUE: op.POP_TOP})
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_FAST               1 (y)
              6 LOAD_FAST                1 (y)
              9 DELETE_FAST              1 (y)
             12 POP_TOP
</pre>
<p>Converting locals to free/cell vars:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; c.STORE_FAST('x')
&gt;&gt;&gt; c.LOAD_FAST('x')

&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_FAST               0 (x)
              6 LOAD_FAST                0 (x)

&gt;&gt;&gt; c.co_freevars = 'y', 'x'
&gt;&gt;&gt; c.co_cellvars = 'z',

&gt;&gt;&gt; c._locals_to_cells()
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_DEREF              2 (x)
              6 LOAD_DEREF               2 (x)

&gt;&gt;&gt; c.DELETE_FAST('x')
&gt;&gt;&gt; c._locals_to_cells()
Traceback (most recent call last):
  ...
AssertionError: Can't delete local 'x' used in nested scope

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; c.STORE_FAST('x')
&gt;&gt;&gt; c.LOAD_FAST('x')

&gt;&gt;&gt; c.co_freevars
()
&gt;&gt;&gt; c.makefree(['x'])
&gt;&gt;&gt; c.co_freevars
('x',)

&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_DEREF              0 (x)
              6 LOAD_DEREF               0 (x)

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; c.STORE_FAST('x')
&gt;&gt;&gt; c.LOAD_FAST('x')
&gt;&gt;&gt; c.makecells(['x'])
&gt;&gt;&gt; c.co_freevars
()
&gt;&gt;&gt; c.co_cellvars
('x',)
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_DEREF              0 (x)
              6 LOAD_DEREF               0 (x)

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; c.STORE_FAST('x')
&gt;&gt;&gt; c.LOAD_FAST('x')
&gt;&gt;&gt; c.makefree('x')
&gt;&gt;&gt; c.makecells(['y'])
&gt;&gt;&gt; c.co_freevars
('x',)
&gt;&gt;&gt; c.co_cellvars
('y',)
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (42)
              3 STORE_DEREF              1 (x)
              6 LOAD_DEREF               1 (x)

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_flags &amp;= ~op.CO_OPTIMIZED
&gt;&gt;&gt; c.makecells(['q'])
Traceback (most recent call last):
  ...
AssertionError: Can't use cellvars in unoptimized scope
</pre>
<p>Auto-free promotion with code parent:</p>
<blockquote>
<pre class="doctest-block">&gt;&gt;&gt; p = Code()
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_FAST('x')
&gt;&gt;&gt; dis(c.code(p))
  0           0 LOAD_DEREF               0 (x)
&gt;&gt;&gt; p.co_cellvars
('x',)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; p = Code()
&gt;&gt;&gt; c = Code.from_function(lambda x,y,z=2: None)
&gt;&gt;&gt; c.LOAD_FAST('x')
&gt;&gt;&gt; c.LOAD_FAST('y')
&gt;&gt;&gt; c.LOAD_FAST('z')
</pre>
<pre class="doctest-block">&gt;&gt;&gt; dis(c.code(p))
  0           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 LOAD_FAST                2 (z)
&gt;&gt;&gt; p.co_cellvars
()
</pre>
<pre class="doctest-block">&gt;&gt;&gt; c.LOAD_FAST('q')
&gt;&gt;&gt; dis(c.code(p))
  0           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 LOAD_FAST                2 (z)
              9 LOAD_DEREF               0 (q)
&gt;&gt;&gt; p.co_cellvars
('q',)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; p = Code()
&gt;&gt;&gt; c = Code.from_function(lambda x,*y,**z: None)
&gt;&gt;&gt; c.LOAD_FAST('q')
&gt;&gt;&gt; c.LOAD_FAST('x')
&gt;&gt;&gt; c.LOAD_FAST('y')
&gt;&gt;&gt; c.LOAD_FAST('z')
&gt;&gt;&gt; dis(c.code(p))
  0           0 LOAD_DEREF               0 (q)
              3 LOAD_FAST                0 (x)
              6 LOAD_FAST                1 (y)
              9 LOAD_FAST                2 (z)
&gt;&gt;&gt; p.co_cellvars
('q',)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; p = Code()
&gt;&gt;&gt; c = Code.from_function(lambda x,*y: None)
&gt;&gt;&gt; c.LOAD_FAST('x')
&gt;&gt;&gt; c.LOAD_FAST('y')
&gt;&gt;&gt; c.LOAD_FAST('z')
&gt;&gt;&gt; dis(c.code(p))
  0           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 LOAD_DEREF               0 (z)
&gt;&gt;&gt; p.co_cellvars
('z',)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; p = Code()
&gt;&gt;&gt; c = Code.from_function(lambda x,**y: None)
&gt;&gt;&gt; c.LOAD_FAST('x')
&gt;&gt;&gt; c.LOAD_FAST('y')
&gt;&gt;&gt; c.LOAD_FAST('z')
&gt;&gt;&gt; dis(c.code(p))
  0           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 LOAD_DEREF               0 (z)
&gt;&gt;&gt; p.co_cellvars
('z',)
</pre>
</blockquote>
<p>Stack tracking on jumps:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; else_ = Label()
&gt;&gt;&gt; end = Label()
&gt;&gt;&gt; c(99, else_.JUMP_IF_TRUE_OR_POP, end.JUMP_FORWARD)
&gt;&gt;&gt; c(else_, Code.POP_TOP, end)
&gt;&gt;&gt; dump(c.code())
                LOAD_CONST               1 (99)
                JUMP_IF_TRUE            L1
                POP_TOP
                JUMP_FORWARD            L2
        L1:     POP_TOP

&gt;&gt;&gt; c.stack_size
0
&gt;&gt;&gt; if sys.version&gt;='2.7':
...     print c.stack_history == [0, 1, 1, 1,    0, 0, 0, None, None, 1]
... else:
...     print c.stack_history == [0, 1, 1, 1, 1, 1, 1, 0, None, None, 1]
True


&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; fwd = c.JUMP_FORWARD()
&gt;&gt;&gt; c.LOAD_CONST(42)    # forward jump marks stack size unknown
Traceback (most recent call last):
  ...
AssertionError: Unknown stack size at this location

&gt;&gt;&gt; c.stack_size = 0
&gt;&gt;&gt; c.LOAD_CONST(42)
&gt;&gt;&gt; fwd()
Traceback (most recent call last):
  ...
AssertionError: Stack level mismatch: actual=1 expected=0

&gt;&gt;&gt; from peak.util.assembler import For
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c(For((), Code.POP_TOP, Pass))
&gt;&gt;&gt; c.return_()
&gt;&gt;&gt; dump(c.code())
                BUILD_TUPLE              0
                GET_ITER
        L1:     FOR_ITER                L2
                POP_TOP
                JUMP_ABSOLUTE           L1
        L2:     LOAD_CONST               0 (None)
                RETURN_VALUE

&gt;&gt;&gt; c.stack_history
[0, 1, 1, 1, 1, 2, 2, 2, 1, None, None, 0, 1, 1, 1]
</pre>
<p>Yield value:</p>
<pre class="literal-block">&gt;&gt;&gt; import sys
&gt;&gt;&gt; from peak.util.assembler import CO_GENERATOR
&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_flags &amp; CO_GENERATOR
0
&gt;&gt;&gt; c(42, Code.YIELD_VALUE)
&gt;&gt;&gt; c.stack_size == int(sys.version&gt;='2.5')
True
&gt;&gt;&gt; (c.co_flags &amp; CO_GENERATOR) == CO_GENERATOR
True
</pre>
<p>Sequence operators and stack tracking:</p>
<p>Function calls and raise:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_GLOBAL('locals')
&gt;&gt;&gt; c.CALL_FUNCTION()   # argc/kwargc default to 0
&gt;&gt;&gt; c.POP_TOP()
&gt;&gt;&gt; c.LOAD_GLOBAL('foo')
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.LOAD_CONST('x')
&gt;&gt;&gt; c.LOAD_CONST(2)
&gt;&gt;&gt; c.CALL_FUNCTION(1,1)    # argc, kwargc
&gt;&gt;&gt; c.POP_TOP()

&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_GLOBAL              0 (locals)
              3 CALL_FUNCTION            0
              6 POP_TOP
              7 LOAD_GLOBAL              1 (foo)
             10 LOAD_CONST               1 (1)
             13 LOAD_CONST               2 ('x')
             16 LOAD_CONST               3 (2)
             19 CALL_FUNCTION          257
             22 POP_TOP

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_GLOBAL('foo')
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.LOAD_CONST('x')
&gt;&gt;&gt; c.LOAD_CONST(2)
&gt;&gt;&gt; c.BUILD_MAP(0)
&gt;&gt;&gt; c.stack_size
5
&gt;&gt;&gt; c.CALL_FUNCTION_KW(1,1)
&gt;&gt;&gt; c.POP_TOP()
&gt;&gt;&gt; c.stack_size
0

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_GLOBAL('foo')
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.LOAD_CONST('x')
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.BUILD_TUPLE(1)
&gt;&gt;&gt; c.CALL_FUNCTION_VAR(0,1)
&gt;&gt;&gt; c.POP_TOP()
&gt;&gt;&gt; c.stack_size
0

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_GLOBAL('foo')
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.LOAD_CONST('x')
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.BUILD_TUPLE(1)
&gt;&gt;&gt; c.BUILD_MAP(0)
&gt;&gt;&gt; c.CALL_FUNCTION_VAR_KW(0,1)
&gt;&gt;&gt; c.POP_TOP()
&gt;&gt;&gt; c.stack_size
0

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.RAISE_VARARGS(0)
&gt;&gt;&gt; c.RAISE_VARARGS(1)
Traceback (most recent call last):
  ...
AssertionError: Stack underflow
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.RAISE_VARARGS(1)

&gt;&gt;&gt; dis(c.code())
  0           0 RAISE_VARARGS            0
              3 LOAD_CONST               1 (1)
              6 RAISE_VARARGS            1
</pre>
<p>Sequence building, unpacking, dup'ing:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.LOAD_CONST(2)
&gt;&gt;&gt; c.BUILD_TUPLE(3)
Traceback (most recent call last):
  ...
AssertionError: Stack underflow

&gt;&gt;&gt; c.BUILD_LIST(3)
Traceback (most recent call last):
  ...
AssertionError: Stack underflow

&gt;&gt;&gt; c.BUILD_TUPLE(2)
&gt;&gt;&gt; c.stack_size
1

&gt;&gt;&gt; c.UNPACK_SEQUENCE(2)
&gt;&gt;&gt; c.stack_size
2
&gt;&gt;&gt; c.DUP_TOPX(3)
Traceback (most recent call last):
  ...
AssertionError: Stack underflow

&gt;&gt;&gt; c.DUP_TOPX(2)
&gt;&gt;&gt; c.stack_size
4
&gt;&gt;&gt; c.LOAD_CONST(3)
&gt;&gt;&gt; c.BUILD_LIST(5)
&gt;&gt;&gt; c.stack_size
1
&gt;&gt;&gt; c.UNPACK_SEQUENCE(5)
&gt;&gt;&gt; c.BUILD_SLICE(3)
&gt;&gt;&gt; c.stack_size
3
&gt;&gt;&gt; c.BUILD_SLICE(3)
&gt;&gt;&gt; c.stack_size
1
&gt;&gt;&gt; c.BUILD_SLICE(2)
Traceback (most recent call last):
  ...
AssertionError: Stack underflow

&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (1)
              3 LOAD_CONST               2 (2)
              6 BUILD_TUPLE              2
              9 UNPACK_SEQUENCE          2
             12 DUP_TOPX                 2
             15 LOAD_CONST               3 (3)
             18 BUILD_LIST               5
             21 UNPACK_SEQUENCE          5
             24 BUILD_SLICE              3
             27 BUILD_SLICE              3
</pre>
<p>Stack levels for MAKE_FUNCTION/MAKE_CLOSURE:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.MAKE_FUNCTION(0)
Traceback (most recent call last):
  ...
AssertionError: Stack underflow

&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.LOAD_CONST(2) # simulate being a function
&gt;&gt;&gt; c.MAKE_FUNCTION(1)
&gt;&gt;&gt; c.stack_size
1

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.MAKE_CLOSURE(0, 0)
Traceback (most recent call last):
  ...
AssertionError: Stack underflow

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(1) # closure
&gt;&gt;&gt; if sys.version&gt;='2.5': c.BUILD_TUPLE(1)
&gt;&gt;&gt; c.LOAD_CONST(2) # default
&gt;&gt;&gt; c.LOAD_CONST(3) # simulate being a function
&gt;&gt;&gt; c.MAKE_CLOSURE(1, 1)
&gt;&gt;&gt; c.stack_size
1

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.LOAD_CONST(2)
&gt;&gt;&gt; if sys.version&gt;='2.5': c.BUILD_TUPLE(2)
&gt;&gt;&gt; c.LOAD_CONST(3) # simulate being a function
&gt;&gt;&gt; c.MAKE_CLOSURE(0, 2)
&gt;&gt;&gt; c.stack_size
1
</pre>
<p>Labels and backpatching forward references:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; where = c.here()
&gt;&gt;&gt; c.LOAD_CONST(1)
&gt;&gt;&gt; c.JUMP_FORWARD(where)
Traceback (most recent call last):
  ...
AssertionError: Relative jumps can't go backwards
</pre>
<p>"Call" combinations:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.set_lineno(1)
&gt;&gt;&gt; c(Call(Global('foo'), [Local('q')],
...        [('x',Const(1))], Local('starargs'))
... )
&gt;&gt;&gt; c.RETURN_VALUE()
&gt;&gt;&gt; dis(c.code())
  1           0 LOAD_GLOBAL              0 (foo)
              3 LOAD_FAST                0 (q)
              6 LOAD_CONST               1 ('x')
              9 LOAD_CONST               2 (1)
             12 LOAD_FAST                1 (starargs)
             15 CALL_FUNCTION_VAR      257
             18 RETURN_VALUE


&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.set_lineno(1)
&gt;&gt;&gt; c(Call(Global('foo'), [Local('q')], [('x',Const(1))],
...        None, Local('kwargs'))
... )
&gt;&gt;&gt; c.RETURN_VALUE()
&gt;&gt;&gt; dis(c.code())
  1           0 LOAD_GLOBAL              0 (foo)
              3 LOAD_FAST                0 (q)
              6 LOAD_CONST               1 ('x')
              9 LOAD_CONST               2 (1)
             12 LOAD_FAST                1 (kwargs)
             15 CALL_FUNCTION_KW       257
             18 RETURN_VALUE
</pre>
<p>Cloning:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code.from_function(lambda (x,y):1, True)
&gt;&gt;&gt; dis(c.code())
  1           0 LOAD_FAST                0 (.0)
              3 UNPACK_SEQUENCE          2
              6 STORE_FAST               1 (x)
              9 STORE_FAST               2 (y)

&gt;&gt;&gt; c = Code.from_function(lambda x,(y,(z,a,b)):1, True)
&gt;&gt;&gt; dis(c.code())
  1           0 LOAD_FAST                1 (.1)
              3 UNPACK_SEQUENCE          2
              6 STORE_FAST               2 (y)
              9 UNPACK_SEQUENCE          3
             12 STORE_FAST               3 (z)
             15 STORE_FAST               4 (a)
             18 STORE_FAST               5 (b)
</pre>
<p>Constant folding for <tt class="literal"><span class="pre">*args</span></tt> and <tt class="literal"><span class="pre">**kw</span></tt>:</p>
<pre class="literal-block">&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_(Call(Const(type), [], [], (1,)))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 (&lt;type 'int'&gt;)
              3 RETURN_VALUE


&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.return_(Call(Const(dict), [], [], [], Const({'x':1})))
&gt;&gt;&gt; dis(c.code())
  0           0 LOAD_CONST               1 ({'x': 1})
              3 RETURN_VALUE
</pre>
<p>Try/Except stack level tracking:</p>
<pre class="literal-block">&gt;&gt;&gt; def class_or_type_of(expr):
...     return Suite([expr, TryExcept(
...         Suite([Getattr(Code.DUP_TOP, '__class__'), Code.ROT_TWO]),
...         [(Const(AttributeError), Call(Const(type), (Code.ROT_TWO,)))]
...     )])

&gt;&gt;&gt; def type_or_class(x): pass
&gt;&gt;&gt; c = Code.from_function(type_or_class)
&gt;&gt;&gt; c.return_(class_or_type_of(Local('x')))
&gt;&gt;&gt; dump(c.code())
                LOAD_FAST                0 (x)
                SETUP_EXCEPT            L1
                DUP_TOP
                LOAD_ATTR                0 (__class__)
                ROT_TWO
                POP_BLOCK
                JUMP_FORWARD            L3
        L1:     DUP_TOP
                LOAD_CONST               1 (&lt;...exceptions.AttributeError...&gt;)
                COMPARE_OP              10 (exception match)
                JUMP_IF_FALSE           L2
                POP_TOP
                POP_TOP
                POP_TOP
                POP_TOP
                LOAD_CONST               2 (&lt;type 'type'&gt;)
                ROT_TWO
                CALL_FUNCTION            1
                JUMP_FORWARD            L3
        L2:     POP_TOP
                END_FINALLY
        L3:     RETURN_VALUE

&gt;&gt;&gt; type_or_class.func_code = c.code()
&gt;&gt;&gt; type_or_class(23)
&lt;type 'int'&gt;
</pre>
<div class="section" id="demo-computed-goto-switch-statement">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id44" name="demo-computed-goto-switch-statement">Demo: "Computed Goto"/"Switch Statement"</a></h2>
<p>Finally, to give an example of a creative way to abuse Python bytecode, here
is an implementation of a simple "switch/case/else" structure:</p>
<pre class="literal-block">&gt;&gt;&gt; from peak.util.assembler import LOAD_CONST, POP_BLOCK

&gt;&gt;&gt; import sys
&gt;&gt;&gt; WHY_CONTINUE = {'2.3':5}.get(sys.version[:3], 32)

&gt;&gt;&gt; def Switch(expr, cases, default=Pass, code=None):
...     if code is None:
...         return expr, tuple(cases), default
...
...     d = {}
...     else_block  = Label()
...     cleanup     = Label()
...     end_switch  = Label()
...
...     code(
...         end_switch.SETUP_LOOP,
...             Call(Const(d.get), [expr]),
...         else_block.JUMP_IF_FALSE,
...             WHY_CONTINUE, Code.END_FINALLY
...     )
...
...     cursize = code.stack_size - 1   # adjust for removed WHY_CONTINUE
...     for key, value in cases:
...         d[const_value(key)] = code.here()
...         code.stack_size = cursize
...         code(value)
...         if code.stack_size is not None: # if the code can fall through,
...             code(cleanup.JUMP_FORWARD)  # jump forward to the cleanup
...
...     code(
...         else_block,
...             Code.POP_TOP, default,
...         cleanup,
...             Code.POP_BLOCK,
...         end_switch
...     )
&gt;&gt;&gt; Switch = nodetype()(Switch)

&gt;&gt;&gt; c = Code()
&gt;&gt;&gt; c.co_argcount=1
&gt;&gt;&gt; c(Switch(Local('x'), [(1,Return(42)),(2,Return("foo"))], Return(27)))
&gt;&gt;&gt; c.return_()

&gt;&gt;&gt; f = new.function(c.code(), globals())
&gt;&gt;&gt; f(1)
42
&gt;&gt;&gt; f(2)
'foo'
&gt;&gt;&gt; f(3)
27

&gt;&gt;&gt; dump(c.code())
                SETUP_LOOP              L2
                LOAD_CONST               1 (&lt;...method get of dict...&gt;)
                LOAD_FAST                0 (x)
                CALL_FUNCTION            1
                JUMP_IF_FALSE           L1
                LOAD_CONST               2 (...)
                END_FINALLY
                LOAD_CONST               3 (42)
                RETURN_VALUE
                LOAD_CONST               4 ('foo')
                RETURN_VALUE
        L1:     POP_TOP
                LOAD_CONST               5 (27)
                RETURN_VALUE
                POP_BLOCK
        L2:     LOAD_CONST               0 (None)
                RETURN_VALUE
</pre>
</div>
<div class="section" id="todo">
<h2><a class="toc-backref" href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler#id45" name="todo">TODO</a></h2>
<ul class="simple">
<li>Test NAME vs. FAST operators flag checks/sets</li>
<li>Test code flags generation/cloning</li>
<li>Exhaustive tests of all opcodes' stack history effects</li>
<li>Test wide jumps and wide argument generation in general</li>
</ul>
</div>
</div>
</div>

<a name="bottom"></a>
<hr><a href="http://www.python.org/"><img align="right" vspace="10" src="./BytecodeAssembler - The PEAK Developers' Center_files/PythonPowered.gif" width="55" height="22" border="0" alt="PythonPowered"></a>

<table border="0" cellspacing="0" cellpadding="0">
<form method="POST" action="http://peak.telecommunity.com/DevCenter/BytecodeAssembler"></form>
<tbody><tr><td>
<input type="hidden" name="action" value="inlinesearch">
<input type="hidden" name="context" value="40">

<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=edit">EditText</a>
of this page
(last modified 2010-08-02 17:38:15)
<br>
<a href="http://peak.telecommunity.com/DevCenter/FindPage?value=BytecodeAssembler">FindPage</a>
 by browsing, title search <input style="font-family:Verdana; font-size:9pt;" type="text" name="text_title" value="" size="15" maxlength="50"><input type="image" src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-search.gif" name="button_title" alt="[?]" hspace="3" width="12" height="12" border="0">, text search <input style="font-family:Verdana; font-size:9pt;" type="text" name="text_full" value="" size="15" maxlength="50"><input type="image" src="./BytecodeAssembler - The PEAK Developers' Center_files/moin-search.gif" name="button_full" alt="[?]" hspace="3" width="12" height="12" border="0"> or an index<br>
Or try one of these actions:
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=AttachFile">AttachFile</a>,
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=DeletePage">DeletePage</a>,
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=LikePages">LikePages</a>,
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=LocalSiteMap">LocalSiteMap</a>,
<a href="http://peak.telecommunity.com/DevCenter/BytecodeAssembler?action=SpellCheck">SpellCheck</a><br>

</td></tr>

</tbody></table>

<!-- MoinMoin 1.159 on sparrow.telecommunity.com served this page in 2.930 secs -->

</body></html>
